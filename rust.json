[
  [
    {
      "name": "visitor",
      "kind": "Module",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 17,
          "character": 0
        },
        "end": {
          "line": 17,
          "character": 12
        }
      },
      "selectionRange": {
        "start": {
          "line": 17,
          "character": 4
        },
        "end": {
          "line": 17,
          "character": 11
        }
      },
      "code_string": "mod visitor;",
      "references": []
    },
    {
      "name": "compile_time_sysroot",
      "detail": "fn() -> Option<String>",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 19,
          "character": 0
        },
        "end": {
          "line": 43,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 21,
          "character": 7
        },
        "end": {
          "line": 21,
          "character": 27
        }
      },
      "code_string": "/// Returns the \"default sysroot\" that Callgraph will use if no `--sysroot` flag is set.\n/// Should be a compile-time constant.\npub fn compile_time_sysroot() -> Option<String> {\n    // option_env! is replaced to a constant at compile time\n    if option_env!(\"RUSTC_STAGE\").is_some() {\n        // This is being built as part of rustc, and gets shipped with rustup.\n        // We can rely on the sysroot computation in librustc.\n        return None;\n    }\n\n    // For builds outside rustc, we need to ensure that we got a sysroot\n    // that gets used as a default. The sysroot computation in librustc would\n    // end up somewhere in the build dir.\n    // Taken from PR <https://github.com/Manishearth/rust-clippy/pull/911>.\n    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n    Some(match (home, toolchain) {\n        (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n        _ => option_env!(\"RUST_SYSROOT\")\n            .expect(\n                \"To build Callgraph without rustup, set the `RUST_SYSROOT` env var at build time\",\n            )\n            .to_owned(),\n    })\n}",
      "references": []
    },
    {
      "name": "analyze",
      "detail": "fn<'tcx>(tcx: &TyCtxt<'tcx>)",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 45,
          "character": 0
        },
        "end": {
          "line": 61,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 45,
          "character": 7
        },
        "end": {
          "line": 45,
          "character": 14
        }
      },
      "code_string": "pub fn analyze<'tcx>(tcx: &TyCtxt<'tcx>) {\n    // Try to determine output directory from command-line arguments\n    let output_dir = get_output_dir().unwrap_or_else(|| PathBuf::from(\"fdep_output\"));\n\n    // Create output directory if it doesn't exist\n    fs::create_dir_all(&output_dir).expect(\"Failed to create output directory\");\n\n    // Initialize visitor with output directory\n    let mut visitor = visitor::CallgraphVisitor::with_output_dir(&tcx, output_dir);\n\n    // Visit all items in the crate\n    tcx.hir().visit_all_item_likes_in_crate(&mut visitor);\n\n    // Dump collected data\n    visitor.dump();\n\n}",
      "references": []
    },
    {
      "name": "get_output_dir",
      "detail": "fn() -> Option<PathBuf>",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 63,
          "character": 0
        },
        "end": {
          "line": 79,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 64,
          "character": 3
        },
        "end": {
          "line": 64,
          "character": 17
        }
      },
      "code_string": "// Helper function to determine output directory from command-line arguments\nfn get_output_dir() -> Option<PathBuf> {\n    let args: Vec<String> = env::args().collect();\n    for (i, arg) in args.iter().enumerate() {\n        if arg == \"--output\" || arg == \"-o\" {\n            if i + 1 < args.len() {\n                return Some(PathBuf::from(&args[i + 1]));\n            }\n        }\n\n        if arg.starts_with(\"--output=\") {\n            let path = arg.split('=').nth(1)?;\n            return Some(PathBuf::from(path));\n        }\n    }\n    None\n}",
      "references": []
    }
  ],
  [
    {
      "name": "skip_generated_code",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 15,
          "character": 0
        },
        "end": {
          "line": 21,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 15,
          "character": 13
        },
        "end": {
          "line": 15,
          "character": 32
        }
      },
      "code_string": "macro_rules! skip_generated_code {\n    ($span: expr) => {\n        if $span.from_expansion() || $span.is_dummy() {\n            return;\n        }\n    };\n}",
      "references": []
    },
    {
      "name": "push_walk_pop",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 23,
          "character": 0
        },
        "end": {
          "line": 32,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 25,
          "character": 13
        },
        "end": {
          "line": 25,
          "character": 26
        }
      },
      "code_string": "// Backup self.cur_fn, set cur_fn to id, continue to walk the AST by executing\n// $walk, then restore self.cur_fn.\nmacro_rules! push_walk_pop {\n    ($this: expr, $id: expr, $walk: expr) => {{\n        let prev_fn = $this.cur_fn;\n        $this.cur_fn = Some($id);\n        $walk;\n        $this.cur_fn = prev_fn;\n    }};\n}",
      "references": []
    },
    {
      "name": "TypeOriginInfo",
      "kind": "Struct",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 34,
          "character": 0
        },
        "end": {
          "line": 42,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 35,
          "character": 11
        },
        "end": {
          "line": 35,
          "character": 25
        }
      },
      "children": [
        {
          "name": "type_name",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 36,
              "character": 4
            },
            "end": {
              "line": 36,
              "character": 25
            }
          },
          "selectionRange": {
            "start": {
              "line": 36,
              "character": 8
            },
            "end": {
              "line": 36,
              "character": 17
            }
          }
        },
        {
          "name": "crate_name",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 37,
              "character": 4
            },
            "end": {
              "line": 37,
              "character": 26
            }
          },
          "selectionRange": {
            "start": {
              "line": 37,
              "character": 8
            },
            "end": {
              "line": 37,
              "character": 18
            }
          }
        },
        {
          "name": "module_path",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 38,
              "character": 4
            },
            "end": {
              "line": 38,
              "character": 27
            }
          },
          "selectionRange": {
            "start": {
              "line": 38,
              "character": 8
            },
            "end": {
              "line": 38,
              "character": 19
            }
          }
        },
        {
          "name": "generic_args",
          "detail": "Vec<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 39,
              "character": 4
            },
            "end": {
              "line": 39,
              "character": 41
            }
          },
          "selectionRange": {
            "start": {
              "line": 39,
              "character": 8
            },
            "end": {
              "line": 39,
              "character": 20
            }
          }
        },
        {
          "name": "is_generic_param",
          "detail": "bool",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 40,
              "character": 4
            },
            "end": {
              "line": 40,
              "character": 30
            }
          },
          "selectionRange": {
            "start": {
              "line": 40,
              "character": 8
            },
            "end": {
              "line": 40,
              "character": 24
            }
          }
        },
        {
          "name": "src_location",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 41,
              "character": 4
            },
            "end": {
              "line": 41,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 41,
              "character": 8
            },
            "end": {
              "line": 41,
              "character": 20
            }
          }
        }
      ],
      "code_string": "#[derive(Debug, Serialize, Clone, PartialEq, Eq, Hash)]\npub struct TypeOriginInfo {\n    pub type_name: String,\n    pub crate_name: String,\n    pub module_path: String,\n    pub generic_args: Vec<TypeOriginInfo>,\n    pub is_generic_param: bool,\n    pub src_location: String,\n}",
      "references": []
    },
    {
      "name": "LiteralInfo",
      "kind": "Struct",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 44,
          "character": 0
        },
        "end": {
          "line": 51,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 45,
          "character": 11
        },
        "end": {
          "line": 45,
          "character": 22
        }
      },
      "children": [
        {
          "name": "value",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 46,
              "character": 4
            },
            "end": {
              "line": 46,
              "character": 21
            }
          },
          "selectionRange": {
            "start": {
              "line": 46,
              "character": 8
            },
            "end": {
              "line": 46,
              "character": 13
            }
          }
        },
        {
          "name": "literal_type",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 47,
              "character": 4
            },
            "end": {
              "line": 47,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 47,
              "character": 8
            },
            "end": {
              "line": 47,
              "character": 20
            }
          }
        },
        {
          "name": "span",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 48,
              "character": 4
            },
            "end": {
              "line": 48,
              "character": 20
            }
          },
          "selectionRange": {
            "start": {
              "line": 48,
              "character": 8
            },
            "end": {
              "line": 48,
              "character": 12
            }
          }
        },
        {
          "name": "line_number",
          "detail": "usize",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 49,
              "character": 4
            },
            "end": {
              "line": 49,
              "character": 26
            }
          },
          "selectionRange": {
            "start": {
              "line": 49,
              "character": 8
            },
            "end": {
              "line": 49,
              "character": 19
            }
          }
        },
        {
          "name": "column_number",
          "detail": "usize",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 50,
              "character": 4
            },
            "end": {
              "line": 50,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 50,
              "character": 8
            },
            "end": {
              "line": 50,
              "character": 21
            }
          }
        }
      ],
      "code_string": "#[derive(Debug, Serialize, Clone)]\npub struct LiteralInfo {\n    pub value: String,\n    pub literal_type: String,\n    pub span: String,\n    pub line_number: usize,\n    pub column_number: usize,\n}",
      "references": []
    },
    {
      "name": "CalledFunctionInfo",
      "kind": "Struct",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 53,
          "character": 0
        },
        "end": {
          "line": 67,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 54,
          "character": 11
        },
        "end": {
          "line": 54,
          "character": 29
        }
      },
      "children": [
        {
          "name": "name",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 55,
              "character": 4
            },
            "end": {
              "line": 55,
              "character": 20
            }
          },
          "selectionRange": {
            "start": {
              "line": 55,
              "character": 8
            },
            "end": {
              "line": 55,
              "character": 12
            }
          }
        },
        {
          "name": "fully_qualified_path",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 56,
              "character": 4
            },
            "end": {
              "line": 56,
              "character": 36
            }
          },
          "selectionRange": {
            "start": {
              "line": 56,
              "character": 8
            },
            "end": {
              "line": 56,
              "character": 28
            }
          }
        },
        {
          "name": "is_method",
          "detail": "bool",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 57,
              "character": 4
            },
            "end": {
              "line": 57,
              "character": 23
            }
          },
          "selectionRange": {
            "start": {
              "line": 57,
              "character": 8
            },
            "end": {
              "line": 57,
              "character": 17
            }
          }
        },
        {
          "name": "receiver_type",
          "detail": "Option<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 58,
              "character": 4
            },
            "end": {
              "line": 58,
              "character": 45
            }
          },
          "selectionRange": {
            "start": {
              "line": 58,
              "character": 8
            },
            "end": {
              "line": 58,
              "character": 21
            }
          }
        },
        {
          "name": "input_types",
          "detail": "Vec<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 59,
              "character": 4
            },
            "end": {
              "line": 59,
              "character": 40
            }
          },
          "selectionRange": {
            "start": {
              "line": 59,
              "character": 8
            },
            "end": {
              "line": 59,
              "character": 19
            }
          }
        },
        {
          "name": "output_types",
          "detail": "Vec<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 60,
              "character": 4
            },
            "end": {
              "line": 60,
              "character": 41
            }
          },
          "selectionRange": {
            "start": {
              "line": 60,
              "character": 8
            },
            "end": {
              "line": 60,
              "character": 20
            }
          }
        },
        {
          "name": "src_location",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 61,
              "character": 4
            },
            "end": {
              "line": 61,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 61,
              "character": 8
            },
            "end": {
              "line": 61,
              "character": 20
            }
          }
        },
        {
          "name": "line_number",
          "detail": "usize",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 62,
              "character": 4
            },
            "end": {
              "line": 62,
              "character": 26
            }
          },
          "selectionRange": {
            "start": {
              "line": 62,
              "character": 8
            },
            "end": {
              "line": 62,
              "character": 19
            }
          }
        },
        {
          "name": "column_number",
          "detail": "usize",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 63,
              "character": 4
            },
            "end": {
              "line": 63,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 63,
              "character": 8
            },
            "end": {
              "line": 63,
              "character": 21
            }
          }
        },
        {
          "name": "origin_crate",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 64,
              "character": 4
            },
            "end": {
              "line": 64,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 64,
              "character": 8
            },
            "end": {
              "line": 64,
              "character": 20
            }
          }
        },
        {
          "name": "origin_module",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 65,
              "character": 4
            },
            "end": {
              "line": 65,
              "character": 29
            }
          },
          "selectionRange": {
            "start": {
              "line": 65,
              "character": 8
            },
            "end": {
              "line": 65,
              "character": 21
            }
          }
        },
        {
          "name": "call_type",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 66,
              "character": 4
            },
            "end": {
              "line": 66,
              "character": 25
            }
          },
          "selectionRange": {
            "start": {
              "line": 66,
              "character": 8
            },
            "end": {
              "line": 66,
              "character": 17
            }
          }
        }
      ],
      "code_string": "#[derive(Debug, Serialize, Clone)]\npub struct CalledFunctionInfo {\n    pub name: String,\n    pub fully_qualified_path: String,\n    pub is_method: bool,\n    pub receiver_type: Option<TypeOriginInfo>,\n    pub input_types: Vec<TypeOriginInfo>,\n    pub output_types: Vec<TypeOriginInfo>,\n    pub src_location: String,\n    pub line_number: usize,\n    pub column_number: usize,\n    pub origin_crate: String,\n    pub origin_module: String,\n    pub call_type: String, // \"function\", \"method\", \"macro\", etc.\n}",
      "references": []
    },
    {
      "name": "Function",
      "kind": "Struct",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 69,
          "character": 0
        },
        "end": {
          "line": 91,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 70,
          "character": 11
        },
        "end": {
          "line": 70,
          "character": 19
        }
      },
      "children": [
        {
          "name": "name",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 71,
              "character": 4
            },
            "end": {
              "line": 71,
              "character": 20
            }
          },
          "selectionRange": {
            "start": {
              "line": 71,
              "character": 8
            },
            "end": {
              "line": 71,
              "character": 12
            }
          }
        },
        {
          "name": "fully_qualified_path",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 72,
              "character": 4
            },
            "end": {
              "line": 72,
              "character": 36
            }
          },
          "selectionRange": {
            "start": {
              "line": 72,
              "character": 8
            },
            "end": {
              "line": 72,
              "character": 28
            }
          }
        },
        {
          "name": "is_method",
          "detail": "bool",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 73,
              "character": 4
            },
            "end": {
              "line": 73,
              "character": 23
            }
          },
          "selectionRange": {
            "start": {
              "line": 73,
              "character": 8
            },
            "end": {
              "line": 73,
              "character": 17
            }
          }
        },
        {
          "name": "self_type",
          "detail": "Option<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 74,
              "character": 4
            },
            "end": {
              "line": 74,
              "character": 41
            }
          },
          "selectionRange": {
            "start": {
              "line": 74,
              "character": 8
            },
            "end": {
              "line": 74,
              "character": 17
            }
          }
        },
        {
          "name": "input_types",
          "detail": "Vec<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 75,
              "character": 4
            },
            "end": {
              "line": 75,
              "character": 40
            }
          },
          "selectionRange": {
            "start": {
              "line": 75,
              "character": 8
            },
            "end": {
              "line": 75,
              "character": 19
            }
          }
        },
        {
          "name": "output_types",
          "detail": "Vec<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 76,
              "character": 4
            },
            "end": {
              "line": 76,
              "character": 41
            }
          },
          "selectionRange": {
            "start": {
              "line": 76,
              "character": 8
            },
            "end": {
              "line": 76,
              "character": 20
            }
          }
        },
        {
          "name": "types_used",
          "detail": "Vec<TypeOriginInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 77,
              "character": 4
            },
            "end": {
              "line": 77,
              "character": 39
            }
          },
          "selectionRange": {
            "start": {
              "line": 77,
              "character": 8
            },
            "end": {
              "line": 77,
              "character": 18
            }
          }
        },
        {
          "name": "literals_used",
          "detail": "Vec<LiteralInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 78,
              "character": 4
            },
            "end": {
              "line": 78,
              "character": 39
            }
          },
          "selectionRange": {
            "start": {
              "line": 78,
              "character": 8
            },
            "end": {
              "line": 78,
              "character": 21
            }
          }
        },
        {
          "name": "functions_called",
          "detail": "Vec<CalledFunctionInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 79,
              "character": 4
            },
            "end": {
              "line": 79,
              "character": 49
            }
          },
          "selectionRange": {
            "start": {
              "line": 79,
              "character": 8
            },
            "end": {
              "line": 79,
              "character": 24
            }
          }
        },
        {
          "name": "methods_called",
          "detail": "Vec<CalledFunctionInfo>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 80,
              "character": 4
            },
            "end": {
              "line": 80,
              "character": 47
            }
          },
          "selectionRange": {
            "start": {
              "line": 80,
              "character": 8
            },
            "end": {
              "line": 80,
              "character": 22
            }
          }
        },
        {
          "name": "where_functions",
          "detail": "HashMap<String, Function>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 81,
              "character": 4
            },
            "end": {
              "line": 81,
              "character": 50
            }
          },
          "selectionRange": {
            "start": {
              "line": 81,
              "character": 8
            },
            "end": {
              "line": 81,
              "character": 23
            }
          }
        },
        {
          "name": "src_location",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 82,
              "character": 4
            },
            "end": {
              "line": 82,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 82,
              "character": 8
            },
            "end": {
              "line": 82,
              "character": 20
            }
          }
        },
        {
          "name": "src_code",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 83,
              "character": 4
            },
            "end": {
              "line": 83,
              "character": 24
            }
          },
          "selectionRange": {
            "start": {
              "line": 83,
              "character": 8
            },
            "end": {
              "line": 83,
              "character": 16
            }
          }
        },
        {
          "name": "line_number_start",
          "detail": "usize",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 84,
              "character": 4
            },
            "end": {
              "line": 84,
              "character": 32
            }
          },
          "selectionRange": {
            "start": {
              "line": 84,
              "character": 8
            },
            "end": {
              "line": 84,
              "character": 25
            }
          }
        },
        {
          "name": "line_number_end",
          "detail": "usize",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 85,
              "character": 4
            },
            "end": {
              "line": 85,
              "character": 30
            }
          },
          "selectionRange": {
            "start": {
              "line": 85,
              "character": 8
            },
            "end": {
              "line": 85,
              "character": 23
            }
          }
        },
        {
          "name": "crate_name",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 86,
              "character": 4
            },
            "end": {
              "line": 86,
              "character": 26
            }
          },
          "selectionRange": {
            "start": {
              "line": 86,
              "character": 8
            },
            "end": {
              "line": 86,
              "character": 18
            }
          }
        },
        {
          "name": "module_path",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 87,
              "character": 4
            },
            "end": {
              "line": 87,
              "character": 27
            }
          },
          "selectionRange": {
            "start": {
              "line": 87,
              "character": 8
            },
            "end": {
              "line": 87,
              "character": 19
            }
          }
        },
        {
          "name": "visibility",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 88,
              "character": 4
            },
            "end": {
              "line": 88,
              "character": 26
            }
          },
          "selectionRange": {
            "start": {
              "line": 88,
              "character": 8
            },
            "end": {
              "line": 88,
              "character": 18
            }
          }
        },
        {
          "name": "doc_comments",
          "detail": "String",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 89,
              "character": 4
            },
            "end": {
              "line": 89,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 89,
              "character": 8
            },
            "end": {
              "line": 89,
              "character": 20
            }
          }
        },
        {
          "name": "attributes",
          "detail": "Vec<String>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 90,
              "character": 4
            },
            "end": {
              "line": 90,
              "character": 31
            }
          },
          "selectionRange": {
            "start": {
              "line": 90,
              "character": 8
            },
            "end": {
              "line": 90,
              "character": 18
            }
          }
        }
      ],
      "code_string": "#[derive(Debug, Serialize, Clone)]\npub struct Function {\n    pub name: String,\n    pub fully_qualified_path: String,\n    pub is_method: bool,\n    pub self_type: Option<TypeOriginInfo>,\n    pub input_types: Vec<TypeOriginInfo>,\n    pub output_types: Vec<TypeOriginInfo>,\n    pub types_used: Vec<TypeOriginInfo>,\n    pub literals_used: Vec<LiteralInfo>,\n    pub functions_called: Vec<CalledFunctionInfo>,\n    pub methods_called: Vec<CalledFunctionInfo>,\n    pub where_functions: HashMap<String, Function>,\n    pub src_location: String,\n    pub src_code: String,\n    pub line_number_start: usize,\n    pub line_number_end: usize,\n    pub crate_name: String,\n    pub module_path: String,\n    pub visibility: String,\n    pub doc_comments: String,\n    pub attributes: Vec<String>,\n}",
      "references": []
    },
    {
      "name": "Call",
      "kind": "Struct",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 93,
          "character": 0
        },
        "end": {
          "line": 104,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 94,
          "character": 11
        },
        "end": {
          "line": 94,
          "character": 15
        }
      },
      "children": [
        {
          "name": "call_expr",
          "detail": "HirId",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 95,
              "character": 4
            },
            "end": {
              "line": 96,
              "character": 24
            }
          },
          "selectionRange": {
            "start": {
              "line": 96,
              "character": 8
            },
            "end": {
              "line": 96,
              "character": 17
            }
          }
        },
        {
          "name": "call_expr_span",
          "detail": "Span",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 97,
              "character": 4
            },
            "end": {
              "line": 97,
              "character": 28
            }
          },
          "selectionRange": {
            "start": {
              "line": 97,
              "character": 8
            },
            "end": {
              "line": 97,
              "character": 22
            }
          }
        },
        {
          "name": "caller",
          "detail": "Option<DefId>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 98,
              "character": 4
            },
            "end": {
              "line": 99,
              "character": 29
            }
          },
          "selectionRange": {
            "start": {
              "line": 99,
              "character": 8
            },
            "end": {
              "line": 99,
              "character": 14
            }
          }
        },
        {
          "name": "caller_span",
          "detail": "Option<Span>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 100,
              "character": 4
            },
            "end": {
              "line": 100,
              "character": 33
            }
          },
          "selectionRange": {
            "start": {
              "line": 100,
              "character": 8
            },
            "end": {
              "line": 100,
              "character": 19
            }
          }
        },
        {
          "name": "callee",
          "detail": "DefId",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 101,
              "character": 4
            },
            "end": {
              "line": 102,
              "character": 21
            }
          },
          "selectionRange": {
            "start": {
              "line": 102,
              "character": 8
            },
            "end": {
              "line": 102,
              "character": 14
            }
          }
        },
        {
          "name": "callee_span",
          "detail": "Span",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 103,
              "character": 4
            },
            "end": {
              "line": 103,
              "character": 25
            }
          },
          "selectionRange": {
            "start": {
              "line": 103,
              "character": 8
            },
            "end": {
              "line": 103,
              "character": 19
            }
          }
        }
      ],
      "code_string": "#[derive(Hash, PartialEq, Eq, Debug)]\npub struct Call {\n    // the call expression\n    pub call_expr: HirId,\n    pub call_expr_span: Span,\n    // possible enclosing function\n    pub caller: Option<DefId>,\n    pub caller_span: Option<Span>,\n    // call target\n    pub callee: DefId,\n    pub callee_span: Span,\n}",
      "references": []
    },
    {
      "name": "CallgraphVisitor",
      "kind": "Struct",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 106,
          "character": 0
        },
        "end": {
          "line": 117,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 106,
          "character": 11
        },
        "end": {
          "line": 106,
          "character": 27
        }
      },
      "children": [
        {
          "name": "tcx",
          "detail": "TyCtxt<'tcx>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 107,
              "character": 4
            },
            "end": {
              "line": 108,
              "character": 25
            }
          },
          "selectionRange": {
            "start": {
              "line": 108,
              "character": 8
            },
            "end": {
              "line": 108,
              "character": 11
            }
          }
        },
        {
          "name": "cur_fn",
          "detail": "Option<DefId>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 110,
              "character": 4
            },
            "end": {
              "line": 111,
              "character": 29
            }
          },
          "selectionRange": {
            "start": {
              "line": 111,
              "character": 8
            },
            "end": {
              "line": 111,
              "character": 14
            }
          }
        },
        {
          "name": "function_data",
          "detail": "Vec<Function>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 113,
              "character": 4
            },
            "end": {
              "line": 114,
              "character": 36
            }
          },
          "selectionRange": {
            "start": {
              "line": 114,
              "character": 8
            },
            "end": {
              "line": 114,
              "character": 21
            }
          }
        },
        {
          "name": "curr_module_path",
          "detail": "Vec<String>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 115,
              "character": 4
            },
            "end": {
              "line": 115,
              "character": 37
            }
          },
          "selectionRange": {
            "start": {
              "line": 115,
              "character": 8
            },
            "end": {
              "line": 115,
              "character": 24
            }
          }
        },
        {
          "name": "output_dir",
          "detail": "Option<PathBuf>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 116,
              "character": 4
            },
            "end": {
              "line": 116,
              "character": 35
            }
          },
          "selectionRange": {
            "start": {
              "line": 116,
              "character": 8
            },
            "end": {
              "line": 116,
              "character": 18
            }
          }
        }
      ],
      "code_string": "pub struct CallgraphVisitor<'tcx> {\n    // type context\n    pub tcx: TyCtxt<'tcx>,\n\n    // tracks the current function we're in during AST walk\n    pub cur_fn: Option<DefId>,\n\n    // Enhanced function data\n    pub function_data: Vec<Function>,\n    pub curr_module_path: Vec<String>,\n    pub output_dir: Option<PathBuf>,\n}",
      "references": []
    },
    {
      "name": "impl CallgraphVisitor<'tcx>",
      "kind": "Object",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 119,
          "character": 0
        },
        "end": {
          "line": 1374,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 119,
          "character": 11
        },
        "end": {
          "line": 119,
          "character": 33
        }
      },
      "children": [
        {
          "name": "new",
          "detail": "fn(tcx: &TyCtxt<'tcx>) -> CallgraphVisitor<'tcx>",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 120,
              "character": 4
            },
            "end": {
              "line": 128,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 120,
              "character": 11
            },
            "end": {
              "line": 120,
              "character": 14
            }
          }
        },
        {
          "name": "with_output_dir",
          "detail": "fn(tcx: &TyCtxt<'tcx>, output_dir: PathBuf) -> CallgraphVisitor<'tcx>",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 130,
              "character": 4
            },
            "end": {
              "line": 134,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 130,
              "character": 11
            },
            "end": {
              "line": 130,
              "character": 26
            }
          }
        },
        {
          "name": "dump",
          "detail": "fn(&self)",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 136,
              "character": 4
            },
            "end": {
              "line": 182,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 136,
              "character": 11
            },
            "end": {
              "line": 136,
              "character": 15
            }
          }
        },
        {
          "name": "push_module",
          "detail": "fn(&mut self, name: String)",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 184,
              "character": 4
            },
            "end": {
              "line": 187,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 185,
              "character": 11
            },
            "end": {
              "line": 185,
              "character": 22
            }
          }
        },
        {
          "name": "pop_module",
          "detail": "fn(&mut self)",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 189,
              "character": 4
            },
            "end": {
              "line": 191,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 189,
              "character": 11
            },
            "end": {
              "line": 189,
              "character": 21
            }
          }
        },
        {
          "name": "current_module_path",
          "detail": "fn(&self) -> String",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 193,
              "character": 4
            },
            "end": {
              "line": 195,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 193,
              "character": 11
            },
            "end": {
              "line": 193,
              "character": 30
            }
          }
        },
        {
          "name": "get_attrs_string",
          "detail": "fn(&self, hir_id: HirId) -> Vec<String>",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 197,
              "character": 4
            },
            "end": {
              "line": 202,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 197,
              "character": 11
            },
            "end": {
              "line": 197,
              "character": 27
            }
          }
        },
        {
          "name": "extract_doc_comments",
          "detail": "fn(&self, hir_id: HirId) -> String",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 204,
              "character": 4
            },
            "end": {
              "line": 221,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 204,
              "character": 11
            },
            "end": {
              "line": 204,
              "character": 31
            }
          }
        },
        {
          "name": "extract_visibility",
          "detail": "fn(&self, owner_id: rustc_hir::OwnerId) -> String",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 223,
              "character": 4
            },
            "end": {
              "line": 231,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 223,
              "character": 11
            },
            "end": {
              "line": 223,
              "character": 29
            }
          }
        },
        {
          "name": "format_span",
          "detail": "fn(&self, span: Span) -> String",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 233,
              "character": 4
            },
            "end": {
              "line": 243,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 233,
              "character": 11
            },
            "end": {
              "line": 233,
              "character": 22
            }
          }
        },
        {
          "name": "get_line_number",
          "detail": "fn(&self, span: Span) -> usize",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 245,
              "character": 4
            },
            "end": {
              "line": 247,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 245,
              "character": 11
            },
            "end": {
              "line": 245,
              "character": 26
            }
          }
        },
        {
          "name": "get_column_number",
          "detail": "fn(&self, span: Span) -> usize",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 249,
              "character": 4
            },
            "end": {
              "line": 256,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 249,
              "character": 11
            },
            "end": {
              "line": 249,
              "character": 28
            }
          }
        },
        {
          "name": "extract_type_from_qpath",
          "detail": "fn( &self, qpath: &rustc_hir::QPath<'_>, span: Span, ) -> Option<TypeOriginInfo>",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 258,
              "character": 4
            },
            "end": {
              "line": 410,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 258,
              "character": 11
            },
            "end": {
              "line": 258,
              "character": 34
            }
          }
        },
        {
          "name": "extract_type_origin_info",
          "detail": "fn(&self, hir_ty: &rustc_hir::Ty<'_>) -> Option<TypeOriginInfo>",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 412,
              "character": 4
            },
            "end": {
              "line": 535,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 412,
              "character": 11
            },
            "end": {
              "line": 412,
              "character": 35
            }
          }
        },
        {
          "name": "extract_type_origin_info_from_ty",
          "detail": "fn( &self, ty: rustc_middle::ty::Ty<'_>, ) -> Option<TypeOriginInfo>",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 537,
              "character": 4
            },
            "end": {
              "line": 937,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 537,
              "character": 11
            },
            "end": {
              "line": 537,
              "character": 43
            }
          }
        },
        {
          "name": "analyze_body",
          "detail": "fn( &self, body: &'tcx rustc_hir::Body<'tcx>, ) -> ( Vec<CalledFunctionInfo>, Vec<CalledFunctionInfo>, Vec<TypeOriginInfo>, Vec<LiteralInfo>, HashMap<String, Function>, )",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 939,
              "character": 4
            },
            "end": {
              "line": 1266,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 939,
              "character": 11
            },
            "end": {
              "line": 939,
              "character": 23
            }
          },
          "children": [
            {
              "name": "BodyCollector",
              "kind": 23,
              "tags": [],
              "deprecated": false,
              "range": {
                "start": {
                  "line": 949,
                  "character": 8
                },
                "end": {
                  "line": 958,
                  "character": 9
                }
              },
              "selectionRange": {
                "start": {
                  "line": 949,
                  "character": 15
                },
                "end": {
                  "line": 949,
                  "character": 28
                }
              },
              "children": [
                {
                  "name": "tcx",
                  "detail": "TyCtxt<'tcx>",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 950,
                      "character": 12
                    },
                    "end": {
                      "line": 950,
                      "character": 29
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 950,
                      "character": 12
                    },
                    "end": {
                      "line": 950,
                      "character": 15
                    }
                  }
                },
                {
                  "name": "functions_called",
                  "detail": "Vec<CalledFunctionInfo>",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 951,
                      "character": 12
                    },
                    "end": {
                      "line": 951,
                      "character": 53
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 951,
                      "character": 12
                    },
                    "end": {
                      "line": 951,
                      "character": 28
                    }
                  }
                },
                {
                  "name": "methods_called",
                  "detail": "Vec<CalledFunctionInfo>",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 952,
                      "character": 12
                    },
                    "end": {
                      "line": 952,
                      "character": 51
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 952,
                      "character": 12
                    },
                    "end": {
                      "line": 952,
                      "character": 26
                    }
                  }
                },
                {
                  "name": "types_used",
                  "detail": "HashSet<TypeOriginInfo>",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 953,
                      "character": 12
                    },
                    "end": {
                      "line": 953,
                      "character": 47
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 953,
                      "character": 12
                    },
                    "end": {
                      "line": 953,
                      "character": 22
                    }
                  }
                },
                {
                  "name": "literals_used",
                  "detail": "Vec<LiteralInfo>",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 954,
                      "character": 12
                    },
                    "end": {
                      "line": 954,
                      "character": 43
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 954,
                      "character": 12
                    },
                    "end": {
                      "line": 954,
                      "character": 25
                    }
                  }
                },
                {
                  "name": "where_functions",
                  "detail": "HashMap<String, Function>",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 955,
                      "character": 12
                    },
                    "end": {
                      "line": 955,
                      "character": 54
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 955,
                      "character": 12
                    },
                    "end": {
                      "line": 955,
                      "character": 27
                    }
                  }
                },
                {
                  "name": "closure_count",
                  "detail": "usize",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 956,
                      "character": 12
                    },
                    "end": {
                      "line": 956,
                      "character": 32
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 956,
                      "character": 12
                    },
                    "end": {
                      "line": 956,
                      "character": 25
                    }
                  }
                },
                {
                  "name": "parent_collector",
                  "detail": "&'a CallgraphVisitor<'tcx>",
                  "kind": 8,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 957,
                      "character": 12
                    },
                    "end": {
                      "line": 957,
                      "character": 56
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 957,
                      "character": 12
                    },
                    "end": {
                      "line": 957,
                      "character": 28
                    }
                  }
                }
              ]
            },
            {
              "name": "impl Visitor<'tcx> for BodyCollector<'a, 'tcx>",
              "kind": 19,
              "tags": [],
              "deprecated": false,
              "range": {
                "start": {
                  "line": 960,
                  "character": 8
                },
                "end": {
                  "line": 1244,
                  "character": 9
                }
              },
              "selectionRange": {
                "start": {
                  "line": 960,
                  "character": 41
                },
                "end": {
                  "line": 960,
                  "character": 64
                }
              },
              "children": [
                {
                  "name": "visit_expr",
                  "detail": "fn(&mut self, expr: &'tcx rustc_hir::Expr<'tcx>)",
                  "kind": 6,
                  "tags": [],
                  "deprecated": false,
                  "range": {
                    "start": {
                      "line": 961,
                      "character": 12
                    },
                    "end": {
                      "line": 1243,
                      "character": 13
                    }
                  },
                  "selectionRange": {
                    "start": {
                      "line": 961,
                      "character": 15
                    },
                    "end": {
                      "line": 961,
                      "character": 25
                    }
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "process_function_data",
          "detail": "fn( &mut self, sig: &rustc_hir::FnSig<'tcx>, hir_id: HirId, body_id: BodyId, span: Span, )",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 1268,
              "character": 4
            },
            "end": {
              "line": 1373,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 1268,
              "character": 11
            },
            "end": {
              "line": 1268,
              "character": 32
            }
          }
        }
      ],
      "code_string": "impl<'tcx> CallgraphVisitor<'tcx> {\n    pub fn new(tcx: &TyCtxt<'tcx>) -> CallgraphVisitor<'tcx> {\n        CallgraphVisitor {\n            tcx: *tcx,\n            cur_fn: None,\n            function_data: Vec::new(),\n            curr_module_path: Vec::new(),\n            output_dir: None,\n        }\n    }\n\n    pub fn with_output_dir(tcx: &TyCtxt<'tcx>, output_dir: PathBuf) -> CallgraphVisitor<'tcx> {\n        let mut visitor = Self::new(tcx);\n        visitor.output_dir = Some(output_dir);\n        visitor\n    }\n\n    pub fn dump(&self) {\n        // Export enhanced function data if output_dir is set\n        if let Some(output_dir) = &self.output_dir {\n            // Create output directory if it doesn't exist\n            fs::create_dir_all(output_dir).expect(\"Failed to create output directory\");\n            // Group functions by file\n            let mut file_to_functions: HashMap<String, Vec<Function>> = HashMap::new();\n\n            for function in &self.function_data {\n                file_to_functions\n                    .entry(function.src_location.to_string())\n                    .or_default()\n                    .push(function.clone());\n            }\n\n            // Create output directories mirroring the project structure\n            for (file_path, functions) in &file_to_functions {\n                // Create output path that mirrors the source file structure\n                println!(\"file_path : {:?}\", file_path);\n                let path = PathBuf::from(file_path);\n                let file_name = path.file_name().unwrap_or_default().to_string_lossy();\n                let parent_path = path.parent().unwrap_or_else(|| std::path::Path::new(\"\"));\n\n                // Create the output directory structure\n                let output_file_dir = output_dir.join(parent_path);\n                fs::create_dir_all(&output_file_dir)\n                    .expect(\"Could not create output directory structure\");\n\n                // Write JSON for this file\n                let json_name = format!(\"{}.json\", file_name.replace(\".rs\", \"\"));\n                let json_path = output_file_dir.join(json_name);\n\n                let json = serde_json::to_string_pretty(&functions)\n                    .expect(\"Failed to serialize file functions\");\n                match fs::write(&json_path, json) {\n                    Ok(_) => {}\n                    Err(err) => println!(\n                        \"{:?} {:?}\",\n                        &format!(\"Could not write JSON for file {}\", file_path),\n                        err\n                    ),\n                };\n\n                println!(\"Created: {}\", json_path.display());\n            }\n        }\n    }\n\n    // Helper methods for enhanced data collection\n    pub fn push_module(&mut self, name: String) {\n        self.curr_module_path.push(name);\n    }\n\n    pub fn pop_module(&mut self) {\n        self.curr_module_path.pop();\n    }\n\n    pub fn current_module_path(&self) -> String {\n        self.curr_module_path.join(\"::\")\n    }\n\n    pub fn get_attrs_string(&self, hir_id: HirId) -> Vec<String> {\n        let attrs = self\n            .tcx\n            .get_attrs(hir_id.owner.to_def_id(), rustc_span::sym::TyCtxt);\n        attrs.map(|attr| format!(\"{:?}\", attr)).collect()\n    }\n\n    pub fn extract_doc_comments(&self, hir_id: HirId) -> String {\n        let attrs = self\n            .tcx\n            .get_attrs(hir_id.owner.to_def_id(), rustc_span::sym::TyCtxt);\n        let mut doc_comments = String::new();\n\n        for attr in attrs {\n            if attr.has_name(rustc_span::Symbol::intern(\"doc\")) {\n                if let Some(doc) = attr.value_str() {\n                    if !doc_comments.is_empty() {\n                        doc_comments.push('\\n');\n                    }\n                    doc_comments.push_str(&doc.to_string());\n                }\n            }\n        }\n        doc_comments\n    }\n\n    pub fn extract_visibility(&self, owner_id: rustc_hir::OwnerId) -> String {\n        match self.tcx.visibility(owner_id.to_def_id()) {\n            Visibility::Public => \"pub\".to_string(),\n            Visibility::Restricted(def_id) => {\n                let path = self.tcx.def_path_str(def_id);\n                format!(\"pub({})\", path)\n            }\n        }\n    }\n\n    pub fn format_span(&self, span: Span) -> String {\n        let source_map = self.tcx.sess.source_map();\n        source_map\n            .span_to_filename(span)\n            .into_local_path()\n            .unwrap()\n            .as_path()\n            .to_str()\n            .unwrap()\n            .to_owned()\n    }\n\n    pub fn get_line_number(&self, span: Span) -> usize {\n        self.tcx.sess.source_map().lookup_char_pos(span.lo()).line\n    }\n\n    pub fn get_column_number(&self, span: Span) -> usize {\n        self.tcx\n            .sess\n            .source_map()\n            .lookup_char_pos(span.lo())\n            .col\n            .to_usize()\n    }\n\n    pub fn extract_type_from_qpath(\n        &self,\n        qpath: &rustc_hir::QPath<'_>,\n        span: Span,\n    ) -> Option<TypeOriginInfo> {\n        match qpath {\n            rustc_hir::QPath::Resolved(_, path) => {\n                match path.res {\n                    rustc_hir::def::Res::Def(_, def_id) => {\n                        let type_name = path\n                            .segments\n                            .last()\n                            .map(|seg| seg.ident.to_string())\n                            .unwrap_or_else(|| \"unknown\".to_string());\n\n                        // Get crate and module info\n                        let crate_name = self.tcx.crate_name(def_id.krate).to_string();\n                        let def_path = self.tcx.def_path(def_id);\n\n                        // Extract module path\n                        let module_path = def_path\n                            .data\n                            .iter()\n                            .take(def_path.data.len().saturating_sub(1)) // Exclude the type name itself\n                            .map(|elem| elem.data.to_string())\n                            .collect::<Vec<_>>()\n                            .join(\"::\");\n\n                        // Handle generic arguments if present\n                        let mut generic_args = Vec::new();\n                        if let Some(args) = path.segments.last().and_then(|seg| seg.args) {\n                            for arg in args.args.iter() {\n                                match arg {\n                                    rustc_hir::GenericArg::Type(ty) => {\n                                        if let Some(type_info) = self.extract_type_origin_info(ty) {\n                                            generic_args.push(type_info);\n                                        }\n                                    }\n                                    rustc_hir::GenericArg::Lifetime(lt) => {\n                                        generic_args.push(TypeOriginInfo {\n                                            type_name: format!(\"'{}\", lt.ident.to_string()),\n                                            crate_name: \"\".to_string(),\n                                            module_path: \"\".to_string(),\n                                            generic_args: Vec::new(),\n                                            is_generic_param: true,\n                                            src_location: self.format_span(lt.ident.span),\n                                        });\n                                    }\n                                    rustc_hir::GenericArg::Const(c) => {\n                                        // Add const generic arguments\n                                        generic_args.push(TypeOriginInfo {\n                                            type_name: format!(\"{:?}\", c),\n                                            crate_name: \"\".to_string(),\n                                            module_path: \"\".to_string(),\n                                            generic_args: Vec::new(),\n                                            is_generic_param: true,\n                                            src_location: self.format_span(c.span()),\n                                        });\n                                    }\n                                    _ => {}\n                                }\n                            }\n                        }\n\n                        // Format the type name with generic arguments if present\n                        let full_type_name = if !generic_args.is_empty() {\n                            let generic_names: Vec<String> =\n                                generic_args.iter().map(|g| g.type_name.clone()).collect();\n                            format!(\"{}<{}>\", type_name, generic_names.join(\", \"))\n                        } else {\n                            type_name.clone()\n                        };\n\n                        Some(TypeOriginInfo {\n                            type_name: full_type_name,\n                            crate_name,\n                            module_path,\n                            generic_args,\n                            is_generic_param: false,\n                            src_location: self.format_span(span),\n                        })\n                    }\n                    rustc_hir::def::Res::PrimTy(prim_ty) => {\n                        // Handle primitive types\n                        Some(TypeOriginInfo {\n                            type_name: format!(\"{:?}\", prim_ty).to_lowercase(),\n                            crate_name: \"core\".to_string(),\n                            module_path: \"primitive\".to_string(),\n                            generic_args: Vec::new(),\n                            is_generic_param: false,\n                            src_location: self.format_span(span),\n                        })\n                    }\n                    rustc_hir::def::Res::SelfTyParam { .. } => {\n                        // Handle Self type parameter\n                        Some(TypeOriginInfo {\n                            type_name: \"Self\".to_string(),\n                            crate_name: \"\".to_string(),\n                            module_path: \"\".to_string(),\n                            generic_args: Vec::new(),\n                            is_generic_param: true,\n                            src_location: self.format_span(span),\n                        })\n                    }\n                    _ => None,\n                }\n            }\n            rustc_hir::QPath::TypeRelative(base, segment) => {\n                // Handle associated types like T::Item\n                if let Some(base_type) = self.extract_type_origin_info(base) {\n                    let assoc_type_name =\n                        format!(\"{}::{}\", base_type.type_name, segment.ident.to_string());\n\n                    let mut generic_args = Vec::new();\n                    generic_args.push(base_type);\n\n                    // Add generic args from the segment if any\n                    // if let Some(args) = segment.args {\n                    //     for arg in args.args.iter() {\n                    //         if let rustc_hir::GenericArg::Type(ty) = arg {\n                    //             if let Some(type_info) = self.extract_type_origin_info(ty) {\n                    //                 generic_args.push(type_info);\n                    //             }\n                    //         }\n                    //     }\n                    // }\n\n                    Some(TypeOriginInfo {\n                        type_name: assoc_type_name,\n                        crate_name: \"\".to_string(), // Can't determine crate for associated type directly\n                        module_path: \"\".to_string(),\n                        generic_args,\n                        is_generic_param: false,\n                        src_location: self.format_span(segment.ident.span),\n                    })\n                } else {\n                    None\n                }\n            }\n            rustc_hir::QPath::LangItem(lang_item, span) => {\n                // Handle lang items\n                Some(TypeOriginInfo {\n                    type_name: format!(\"<lang_item:{:?}>\", lang_item),\n                    crate_name: \"core\".to_string(),\n                    module_path: \"lang_items\".to_string(),\n                    generic_args: Vec::new(),\n                    is_generic_param: false,\n                    src_location: self.format_span(*span),\n                })\n            }\n            _ => None,\n        }\n    }\n\n    pub fn extract_type_origin_info(&self, hir_ty: &rustc_hir::Ty<'_>) -> Option<TypeOriginInfo> {\n        match &hir_ty.kind {\n            rustc_hir::TyKind::Path(qpath) => self.extract_type_from_qpath(qpath, hir_ty.span),\n            rustc_hir::TyKind::Ref(lifetime, mutty) => {\n                let mut base_type = self.extract_type_origin_info(mutty.ty)?;\n                base_type.type_name = format!(\n                    \"&{}{}\",\n                    if mutty.mutbl.is_mut() { \"mut \" } else { \"\" },\n                    base_type.type_name\n                );\n                Some(base_type)\n            }\n            rustc_hir::TyKind::Slice(ty) => {\n                let element_type = self.extract_type_origin_info(ty)?;\n                Some(TypeOriginInfo {\n                    type_name: format!(\"[{}]\", element_type.type_name),\n                    crate_name: \"core\".to_string(),\n                    module_path: \"slice\".to_string(),\n                    generic_args: vec![element_type],\n                    is_generic_param: false,\n                    src_location: self.format_span(hir_ty.span),\n                })\n            }\n            rustc_hir::TyKind::Array(ty, len) => {\n                let element_type = self.extract_type_origin_info(ty)?;\n                Some(TypeOriginInfo {\n                    type_name: format!(\"[{}; {:?}]\", element_type.type_name, len),\n                    crate_name: \"core\".to_string(),\n                    module_path: \"array\".to_string(),\n                    generic_args: vec![element_type],\n                    is_generic_param: false,\n                    src_location: self.format_span(hir_ty.span),\n                })\n            }\n            rustc_hir::TyKind::Tup(tys) => {\n                let mut tuple_elements = Vec::new();\n                for ty in tys.iter() {\n                    if let Some(element_type) = self.extract_type_origin_info(ty) {\n                        tuple_elements.push(element_type);\n                    }\n                }\n\n                let tuple_type_name = if tuple_elements.is_empty() {\n                    \"()\".to_string()\n                } else {\n                    let element_names: Vec<String> =\n                        tuple_elements.iter().map(|e| e.type_name.clone()).collect();\n                    format!(\"({})\", element_names.join(\", \"))\n                };\n\n                Some(TypeOriginInfo {\n                    type_name: tuple_type_name,\n                    crate_name: \"core\".to_string(),\n                    module_path: \"tuple\".to_string(),\n                    generic_args: tuple_elements,\n                    is_generic_param: false,\n                    src_location: self.format_span(hir_ty.span),\n                })\n            }\n            rustc_hir::TyKind::BareFn(fn_decl) => {\n                let mut param_types = Vec::new();\n                for param in fn_decl.decl.inputs.iter() {\n                    if let Some(param_type) = self.extract_type_origin_info(param) {\n                        param_types.push(param_type);\n                    }\n                }\n\n                let mut return_type = None;\n                if let rustc_hir::FnRetTy::Return(ret_ty) = &fn_decl.decl.output {\n                    return_type = self.extract_type_origin_info(ret_ty);\n                }\n\n                let fn_type_name = format!(\n                    \"fn({}) -> {}\",\n                    param_types\n                        .iter()\n                        .map(|p| p.type_name.clone())\n                        .collect::<Vec<_>>()\n                        .join(\", \"),\n                    return_type\n                        .as_ref()\n                        .map_or(\"()\".to_string(), |t| t.type_name.clone())\n                );\n\n                let mut generic_args = param_types;\n                if let Some(ret) = return_type {\n                    generic_args.push(ret);\n                }\n\n                Some(TypeOriginInfo {\n                    type_name: fn_type_name,\n                    crate_name: \"core\".to_string(),\n                    module_path: \"primitive\".to_string(),\n                    generic_args,\n                    is_generic_param: false,\n                    src_location: self.format_span(hir_ty.span),\n                })\n            }\n            rustc_hir::TyKind::Never => Some(TypeOriginInfo {\n                type_name: \"!\".to_string(),\n                crate_name: \"core\".to_string(),\n                module_path: \"never\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: self.format_span(hir_ty.span),\n            }),\n            rustc_hir::TyKind::Infer => Some(TypeOriginInfo {\n                type_name: \"_\".to_string(),\n                crate_name: \"\".to_string(),\n                module_path: \"\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: self.format_span(hir_ty.span),\n            }),\n            _ => Some(TypeOriginInfo {\n                type_name: format!(\"{:?}\", hir_ty.kind),\n                crate_name: \"unknown\".to_string(),\n                module_path: \"unknown\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: self.format_span(hir_ty.span),\n            }),\n        }\n    }\n\n    pub fn extract_type_origin_info_from_ty(\n        &self,\n        ty: rustc_middle::ty::Ty<'_>,\n    ) -> Option<TypeOriginInfo> {\n        match ty.kind() {\n            TyKind::Bool => Some(TypeOriginInfo {\n                type_name: \"bool\".to_string(),\n                crate_name: \"core\".to_string(),\n                module_path: \"primitive\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            }),\n            TyKind::Char => Some(TypeOriginInfo {\n                type_name: \"char\".to_string(),\n                crate_name: \"core\".to_string(),\n                module_path: \"primitive\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            }),\n            TyKind::Int(int_ty) => Some(TypeOriginInfo {\n                type_name: format!(\"{:?}\", int_ty).to_lowercase(),\n                crate_name: \"core\".to_string(),\n                module_path: \"primitive\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            }),\n            TyKind::Uint(uint_ty) => Some(TypeOriginInfo {\n                type_name: format!(\"{:?}\", uint_ty).to_lowercase(),\n                crate_name: \"core\".to_string(),\n                module_path: \"primitive\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            }),\n            TyKind::Float(float_ty) => Some(TypeOriginInfo {\n                type_name: format!(\"{:?}\", float_ty).to_lowercase(),\n                crate_name: \"core\".to_string(),\n                module_path: \"primitive\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            }),\n            TyKind::Adt(adt_def, substs) => {\n                let def_id = adt_def.did();\n                let crate_name = self.tcx.crate_name(def_id.krate).to_string();\n                let def_path = self.tcx.def_path(def_id);\n\n                let mut path_segments = Vec::new();\n                for data in &def_path.data {\n                    path_segments.push(data.data.to_string());\n                }\n\n                let type_name = path_segments\n                    .last()\n                    .cloned()\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                let module_path = path_segments\n                    .iter()\n                    .take(path_segments.len().saturating_sub(1))\n                    .cloned()\n                    .collect::<Vec<_>>()\n                    .join(\"::\");\n\n                let mut generic_args = Vec::new();\n                for subst in substs.iter() {\n                    if let GenericArgKind::Type(ty) = subst.unpack() {\n                        if let Some(arg_info) = self.extract_type_origin_info_from_ty(ty) {\n                            generic_args.push(arg_info);\n                        }\n                    }\n                }\n\n                let full_type_name = if !generic_args.is_empty() {\n                    let generic_names: Vec<String> =\n                        generic_args.iter().map(|g| g.type_name.clone()).collect();\n                    format!(\"{}<{}>\", type_name, generic_names.join(\", \"))\n                } else {\n                    type_name.clone()\n                };\n\n                Some(TypeOriginInfo {\n                    type_name: full_type_name,\n                    crate_name,\n                    module_path,\n                    generic_args,\n                    is_generic_param: false,\n                    src_location: \"\".to_string(),\n                })\n            }\n            TyKind::Foreign(def_id) => {\n                let crate_name = self.tcx.crate_name(def_id.krate).to_string();\n                let def_path = self.tcx.def_path(*def_id);\n\n                let mut path_segments = Vec::new();\n                for data in &def_path.data {\n                    path_segments.push(data.data.to_string());\n                }\n\n                let type_name = path_segments\n                    .last()\n                    .cloned()\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                let module_path = path_segments\n                    .iter()\n                    .take(path_segments.len().saturating_sub(1))\n                    .cloned()\n                    .collect::<Vec<_>>()\n                    .join(\"::\");\n\n                Some(TypeOriginInfo {\n                    type_name,\n                    crate_name,\n                    module_path,\n                    generic_args: Vec::new(),\n                    is_generic_param: false,\n                    src_location: \"\".to_string(),\n                })\n            }\n            TyKind::Str => Some(TypeOriginInfo {\n                type_name: \"str\".to_string(),\n                crate_name: \"core\".to_string(),\n                module_path: \"primitive\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            }),\n            TyKind::Array(element_ty, len) => {\n                if let Some(element_info) = self.extract_type_origin_info_from_ty(*element_ty) {\n                    let array_len = match len.kind() {\n                        ConstKind::Value(val, _) => format!(\"{:?}\", val),\n                        _ => \"?\".to_string(),\n                    };\n\n                    Some(TypeOriginInfo {\n                        type_name: format!(\"[{}; {}]\", element_info.type_name, array_len),\n                        crate_name: \"core\".to_string(),\n                        module_path: \"array\".to_string(),\n                        generic_args: vec![element_info],\n                        is_generic_param: false,\n                        src_location: \"\".to_string(),\n                    })\n                } else {\n                    None\n                }\n            }\n            TyKind::Slice(element_ty) => {\n                if let Some(element_info) = self.extract_type_origin_info_from_ty(*element_ty) {\n                    Some(TypeOriginInfo {\n                        type_name: format!(\"[{}]\", element_info.type_name),\n                        crate_name: \"core\".to_string(),\n                        module_path: \"slice\".to_string(),\n                        generic_args: vec![element_info],\n                        is_generic_param: false,\n                        src_location: \"\".to_string(),\n                    })\n                } else {\n                    None\n                }\n            }\n            TyKind::RawPtr(ty_and_mut, _) => {\n                if let Some(pointee_info) = self.extract_type_origin_info_from_ty(*ty_and_mut) {\n                    let mutability = if ty_and_mut.is_adt() { \"mut\" } else { \"const\" };\n                    Some(TypeOriginInfo {\n                        type_name: format!(\"*{} {}\", mutability, pointee_info.type_name),\n                        crate_name: \"core\".to_string(),\n                        module_path: \"primitive\".to_string(),\n                        generic_args: vec![pointee_info],\n                        is_generic_param: false,\n                        src_location: \"\".to_string(),\n                    })\n                } else {\n                    None\n                }\n            }\n            TyKind::Ref(region, ty, mutbl) => {\n                if let Some(referenced_info) = self.extract_type_origin_info_from_ty(*ty) {\n                    let mutability = if mutbl.is_mut() { \"mut\" } else { \"\" };\n                    let lifetime = match region.kind() {\n                        RegionKind::ReStatic => \"'static\",\n                        _ => \"'_\",\n                    };\n\n                    Some(TypeOriginInfo {\n                        type_name: format!(\n                            \"&{} {}{}{}\",\n                            lifetime,\n                            if !mutability.is_empty() {\n                                mutability\n                            } else {\n                                \"\"\n                            },\n                            if !mutability.is_empty() { \" \" } else { \"\" },\n                            referenced_info.type_name\n                        ),\n                        crate_name: \"core\".to_string(),\n                        module_path: \"primitive\".to_string(),\n                        generic_args: vec![referenced_info],\n                        is_generic_param: false,\n                        src_location: \"\".to_string(),\n                    })\n                } else {\n                    None\n                }\n            }\n            TyKind::FnDef(def_id, substs) => {\n                let crate_name = self.tcx.crate_name(def_id.krate).to_string();\n                let def_path = self.tcx.def_path(*def_id);\n\n                let mut path_segments = Vec::new();\n                for data in &def_path.data {\n                    path_segments.push(data.data.to_string());\n                }\n\n                let fn_name = path_segments\n                    .last()\n                    .cloned()\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                let module_path = path_segments\n                    .iter()\n                    .take(path_segments.len().saturating_sub(1))\n                    .cloned()\n                    .collect::<Vec<_>>()\n                    .join(\"::\");\n\n                let fn_sig = self.tcx.fn_sig(*def_id);\n                let sig = fn_sig.skip_binder();\n\n                let mut param_types = Vec::new();\n                for param_ty in sig.inputs().iter() {\n                    if let Some(param_info) =\n                        self.extract_type_origin_info_from_ty(*param_ty.skip_binder())\n                    {\n                        param_types.push(param_info);\n                    }\n                }\n\n                let mut return_type = None;\n                if let Some(ret_info) =\n                    self.extract_type_origin_info_from_ty(sig.output().skip_binder())\n                {\n                    return_type = Some(ret_info);\n                }\n\n                let fn_type_name = format!(\n                    \"fn({}) -> {}\",\n                    param_types\n                        .iter()\n                        .map(|p| p.type_name.clone())\n                        .collect::<Vec<_>>()\n                        .join(\", \"),\n                    return_type\n                        .as_ref()\n                        .map_or(\"()\".to_string(), |t| t.type_name.clone())\n                );\n\n                let mut generic_args = param_types;\n                if let Some(ret) = return_type {\n                    generic_args.push(ret);\n                }\n\n                Some(TypeOriginInfo {\n                    type_name: fn_type_name,\n                    crate_name,\n                    module_path,\n                    generic_args,\n                    is_generic_param: false,\n                    src_location: \"\".to_string(),\n                })\n            }\n            TyKind::FnPtr(poly_fn_sig) => {\n                let fn_sig = poly_fn_sig.skip_binder();\n\n                let mut param_types = Vec::new();\n                for param_ty in fn_sig.inputs().iter() {\n                    if let Some(param_info) = self.extract_type_origin_info_from_ty(*param_ty) {\n                        param_types.push(param_info);\n                    }\n                }\n\n                let mut return_type = None;\n                if let Some(ret_info) = self.extract_type_origin_info_from_ty(fn_sig.output()) {\n                    return_type = Some(ret_info);\n                }\n\n                let fn_type_name = format!(\n                    \"fn({}) -> {}\",\n                    param_types\n                        .iter()\n                        .map(|p| p.type_name.clone())\n                        .collect::<Vec<_>>()\n                        .join(\", \"),\n                    return_type\n                        .as_ref()\n                        .map_or(\"()\".to_string(), |t| t.type_name.clone())\n                );\n\n                let mut generic_args = param_types;\n                if let Some(ret) = return_type {\n                    generic_args.push(ret);\n                }\n\n                Some(TypeOriginInfo {\n                    type_name: fn_type_name,\n                    crate_name: \"core\".to_string(),\n                    module_path: \"primitive\".to_string(),\n                    generic_args,\n                    is_generic_param: false,\n                    src_location: \"\".to_string(),\n                })\n            }\n            TyKind::Closure(def_id, substs) => {\n                // In Rust 1.88, closure signature access might have changed\n                let closure_sig = substs.as_closure().sig();\n                let sig = closure_sig.skip_binder();\n\n                let mut param_types = Vec::new();\n                for param_ty in sig.inputs().iter() {\n                    if let Some(param_info) = self.extract_type_origin_info_from_ty(*param_ty) {\n                        param_types.push(param_info);\n                    }\n                }\n\n                let mut return_type = None;\n                if let Some(ret_info) = self.extract_type_origin_info_from_ty(sig.output()) {\n                    return_type = Some(ret_info);\n                }\n\n                let path_str = self.tcx.def_path_str(*def_id);\n\n                let closure_type_name = format!(\n                    \"Closure<({}) -> {}>\",\n                    param_types\n                        .iter()\n                        .map(|p| p.type_name.clone())\n                        .collect::<Vec<_>>()\n                        .join(\", \"),\n                    return_type\n                        .as_ref()\n                        .map_or(\"()\".to_string(), |t| t.type_name.clone())\n                );\n\n                let mut generic_args = param_types;\n                if let Some(ret) = return_type {\n                    generic_args.push(ret);\n                }\n\n                Some(TypeOriginInfo {\n                    type_name: closure_type_name,\n                    crate_name: self.tcx.crate_name(def_id.krate).to_string(),\n                    module_path: path_str,\n                    generic_args,\n                    is_generic_param: false,\n                    src_location: \"\".to_string(),\n                })\n            }\n            TyKind::Tuple(tys) => {\n                let mut tuple_elements = Vec::new();\n                for ty in tys.iter() {\n                    if let Some(element_info) = self.extract_type_origin_info_from_ty(ty) {\n                        tuple_elements.push(element_info);\n                    }\n                }\n\n                let tuple_type_name = if tuple_elements.is_empty() {\n                    \"()\".to_string()\n                } else {\n                    let element_names: Vec<String> =\n                        tuple_elements.iter().map(|e| e.type_name.clone()).collect();\n                    format!(\"({})\", element_names.join(\", \"))\n                };\n\n                Some(TypeOriginInfo {\n                    type_name: tuple_type_name,\n                    crate_name: \"core\".to_string(),\n                    module_path: \"primitive\".to_string(),\n                    generic_args: tuple_elements,\n                    is_generic_param: false,\n                    src_location: \"\".to_string(),\n                })\n            }\n            TyKind::Param(param_ty) => Some(TypeOriginInfo {\n                type_name: param_ty.name.to_string(),\n                crate_name: \"\".to_string(),\n                module_path: \"\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: true,\n                src_location: \"\".to_string(),\n            }),\n            _ => Some(TypeOriginInfo {\n                type_name: format!(\"{:?}\", ty),\n                crate_name: \"unknown\".to_string(),\n                module_path: \"unknown\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            }),\n        }\n    }\n\n    pub fn analyze_body(\n        &self,\n        body: &'tcx rustc_hir::Body<'tcx>,\n    ) -> (\n        Vec<CalledFunctionInfo>,\n        Vec<CalledFunctionInfo>,\n        Vec<TypeOriginInfo>,\n        Vec<LiteralInfo>,\n        HashMap<String, Function>,\n    ) {\n        struct BodyCollector<'a, 'tcx> {\n            tcx: TyCtxt<'tcx>,\n            functions_called: Vec<CalledFunctionInfo>,\n            methods_called: Vec<CalledFunctionInfo>,\n            types_used: HashSet<TypeOriginInfo>,\n            literals_used: Vec<LiteralInfo>,\n            where_functions: HashMap<String, Function>,\n            closure_count: usize,\n            parent_collector: &'a CallgraphVisitor<'tcx>,\n        }\n\n        impl<'a, 'tcx> Visitor<'tcx> for BodyCollector<'a, 'tcx> {\n            fn visit_expr(&mut self, expr: &'tcx rustc_hir::Expr<'tcx>) {\n                let def_id = expr.hir_id.owner.to_def_id();\n                // let typeck = self.tcx.typeck(def_id);\n                let typeck = if def_id.is_local() {\n                    // Convert to LocalDefId for typeck\n                    self.tcx.typeck(def_id.as_local().unwrap())\n                } else {\n                    // For non-local definitions, you might need to handle differently\n                    panic!(\"Cannot perform type checking on non-local definitions\")\n                    // Or find an alternative approach for non-local defs\n                };\n                let expr_ty = typeck.expr_ty(expr);\n\n                // Add the expression type to types_used\n                if let Some(type_info) = self\n                    .parent_collector\n                    .extract_type_origin_info_from_ty(expr_ty)\n                {\n                    self.types_used.insert(type_info);\n                }\n\n                match &expr.kind {\n                    // Function calls\n                    rustc_hir::ExprKind::Call(func, args) => {\n                        if let rustc_hir::ExprKind::Path(qpath) = &func.kind {\n                            let res = typeck.qpath_res(qpath, func.hir_id);\n\n                            if let Some(def_id) = res.opt_def_id() {\n                                let fn_name = self.tcx.def_path_str(def_id);\n                                let span = func.span;\n\n                                // Extract origin information\n                                let crate_name = self.tcx.crate_name(def_id.krate).to_string();\n                                let def_path = self.tcx.def_path(def_id);\n                                let module_path = def_path\n                                    .data\n                                    .iter()\n                                    .take(def_path.data.len().saturating_sub(1))\n                                    .map(|x| x.data.to_string())\n                                    .collect::<Vec<_>>()\n                                    .join(\"::\");\n\n                                // Get function inputs/outputs\n                                let mut input_types = Vec::new();\n                                let mut output_types = Vec::new();\n\n                                let fn_ty = self.tcx.type_of(def_id).skip_binder();\n                                if let TyKind::FnDef(_, _) = fn_ty.kind() {\n                                    let fn_sig = self.tcx.fn_sig(def_id);\n                                    let sig = fn_sig.skip_binder();\n\n                                    // Get input types\n                                    for arg_ty in sig.inputs().iter() {\n                                        if let Some(type_info) = self\n                                            .parent_collector\n                                            .extract_type_origin_info_from_ty(*arg_ty.skip_binder())\n                                        {\n                                            input_types.push(type_info);\n                                        }\n                                    }\n\n                                    // Get output type\n                                    if let Some(output_info) =\n                                        self.parent_collector.extract_type_origin_info_from_ty(\n                                            sig.output().skip_binder(),\n                                        )\n                                    {\n                                        output_types.push(output_info);\n                                    }\n                                }\n\n                                let name =\n                                    fn_name.split(\"::\").last().unwrap_or(&fn_name).to_string();\n\n                                self.functions_called.push(CalledFunctionInfo {\n                                    name,\n                                    fully_qualified_path: fn_name,\n                                    is_method: false,\n                                    receiver_type: None,\n                                    input_types,\n                                    output_types,\n                                    src_location: self.parent_collector.format_span(span),\n                                    line_number: self.parent_collector.get_line_number(span),\n                                    column_number: self.parent_collector.get_column_number(span),\n                                    origin_crate: crate_name,\n                                    origin_module: module_path,\n                                    call_type: \"function\".to_string(),\n                                });\n                            }\n                        }\n                    }\n\n                    // Method calls\n                    rustc_hir::ExprKind::MethodCall(path, receiver, args, span) => {\n                        let method_name = path.ident.to_string();\n                        let span = path.ident.span;\n\n                        // Get receiver type\n                        let receiver_ty = typeck.expr_ty(receiver);\n                        let receiver_type = self\n                            .parent_collector\n                            .extract_type_origin_info_from_ty(receiver_ty);\n\n                        // Get method definition\n                        if let Some(def_id) = typeck.type_dependent_def_id(expr.hir_id) {\n                            let method_full_name = self.tcx.def_path_str(def_id);\n\n                            // Extract origin information\n                            let crate_name = self.tcx.crate_name(def_id.krate).to_string();\n                            let def_path = self.tcx.def_path(def_id);\n                            let module_path = def_path\n                                .data\n                                .iter()\n                                .take(def_path.data.len().saturating_sub(1))\n                                .map(|x| x.data.to_string())\n                                .collect::<Vec<_>>()\n                                .join(\"::\");\n\n                            // Get method inputs/outputs\n                            let mut input_types = Vec::new();\n                            let mut output_types = Vec::new();\n\n                            let fn_ty = self.tcx.type_of(def_id).skip_binder();\n                            if let TyKind::FnDef(_, _) = fn_ty.kind() {\n                                let fn_sig = self.tcx.fn_sig(def_id);\n                                let sig = fn_sig.skip_binder();\n\n                                // Skip the first input (self)\n                                for arg_ty in sig.inputs().iter().skip(1) {\n                                    if let Some(type_info) = self\n                                        .parent_collector\n                                        .extract_type_origin_info_from_ty(*arg_ty.skip_binder())\n                                    {\n                                        input_types.push(type_info);\n                                    }\n                                }\n\n                                // Get output type\n                                if let Some(output_info) = self\n                                    .parent_collector\n                                    .extract_type_origin_info_from_ty(sig.output().skip_binder())\n                                {\n                                    output_types.push(output_info);\n                                }\n                            }\n\n                            self.methods_called.push(CalledFunctionInfo {\n                                name: method_name,\n                                fully_qualified_path: method_full_name,\n                                is_method: true,\n                                receiver_type,\n                                input_types,\n                                output_types,\n                                src_location: self.parent_collector.format_span(span),\n                                line_number: self.parent_collector.get_line_number(span),\n                                column_number: self.parent_collector.get_column_number(span),\n                                origin_crate: crate_name,\n                                origin_module: module_path,\n                                call_type: \"method\".to_string(),\n                            });\n                        }\n                    }\n\n                    // Literals\n                    rustc_hir::ExprKind::Lit(lit) => {\n                        let span = lit.span;\n                        let lit_value = self\n                            .tcx\n                            .sess\n                            .source_map()\n                            .span_to_snippet(span)\n                            .unwrap_or_else(|_| \"<<literal value unavailable>>\".to_string());\n\n                        let lit_type = match expr_ty.kind() {\n                            TyKind::Int(_) => \"integer\".to_string(),\n                            TyKind::Uint(_) => \"unsigned integer\".to_string(),\n                            TyKind::Float(_) => \"float\".to_string(),\n                            TyKind::Bool => \"boolean\".to_string(),\n                            TyKind::Char => \"char\".to_string(),\n                            TyKind::Str => \"string\".to_string(),\n                            _ => format!(\"{:?}\", expr_ty.kind()),\n                        };\n\n                        self.literals_used.push(LiteralInfo {\n                            value: lit_value,\n                            literal_type: lit_type,\n                            span: self.parent_collector.format_span(span),\n                            line_number: self.parent_collector.get_line_number(span),\n                            column_number: self.parent_collector.get_column_number(span),\n                        });\n                    }\n\n                    // Closures\n                    rustc_hir::ExprKind::Closure(&rustc_hir::Closure { body, .. }) => {\n                        self.closure_count += 1;\n                        let closure_name = format!(\"closure_{}\", self.closure_count);\n\n                        let body = self.tcx.hir().body(body); //self.tcx.hir_body(body);\n                        let closure_ty = typeck.expr_ty(expr);\n\n                        let mut child_collector = BodyCollector {\n                            tcx: self.tcx,\n                            functions_called: Vec::new(),\n                            methods_called: Vec::new(),\n                            types_used: HashSet::new(),\n                            literals_used: Vec::new(),\n                            where_functions: HashMap::new(),\n                            closure_count: 0,\n                            parent_collector: self.parent_collector,\n                        };\n\n                        child_collector.visit_expr(&body.value);\n\n                        // Build inputs/outputs\n                        let mut input_types = Vec::new();\n                        let mut output_types = Vec::new();\n\n                        if let TyKind::Closure(def_id, substs) = closure_ty.kind() {\n                            let closure_sig = substs.as_closure().sig();\n                            let sig = closure_sig.skip_binder();\n\n                            // Get input types\n                            for arg_ty in sig.inputs().iter() {\n                                if let Some(type_info) = self\n                                    .parent_collector\n                                    .extract_type_origin_info_from_ty(*arg_ty)\n                                {\n                                    input_types.push(type_info);\n                                }\n                            }\n\n                            // Get output type\n                            if let Some(output_info) = self\n                                .parent_collector\n                                .extract_type_origin_info_from_ty(sig.output())\n                            {\n                                output_types.push(output_info);\n                            }\n                        }\n\n                        let span = expr.span;\n                        let closure_src = self\n                            .tcx\n                            .sess\n                            .source_map()\n                            .span_to_snippet(span)\n                            .unwrap_or_else(|_| \"<<closure source unavailable>>\".to_string());\n\n                        let line_start = self.parent_collector.get_line_number(span);\n                        let line_end = self.tcx.sess.source_map().lookup_char_pos(span.hi()).line;\n                        let attributes = self.parent_collector.get_attrs_string(body.id().hir_id);\n                        let closure_info = Function {\n                            name: closure_name.clone(),\n                            fully_qualified_path: closure_name.clone(),\n                            is_method: false,\n                            self_type: None,\n                            input_types,\n                            output_types,\n                            types_used: child_collector.types_used.into_iter().collect(),\n                            literals_used: child_collector.literals_used,\n                            functions_called: child_collector.functions_called,\n                            methods_called: child_collector.methods_called,\n                            where_functions: child_collector.where_functions,\n                            src_location: self.parent_collector.format_span(span),\n                            src_code: closure_src,\n                            line_number_start: line_start,\n                            line_number_end: line_end,\n                            crate_name: \"local\".to_string(),\n                            module_path: \"closure\".to_string(),\n                            visibility: \"private\".to_string(),\n                            doc_comments: \"\".to_string(),\n                            attributes: attributes,\n                        };\n\n                        self.where_functions.insert(closure_name, closure_info);\n                    }\n\n                    _ => {}\n                }\n\n                // Recursively visit child expressions\n                walk_expr(self, expr);\n            }\n        }\n\n        let mut collector = BodyCollector {\n            tcx: self.tcx,\n            functions_called: Vec::new(),\n            methods_called: Vec::new(),\n            types_used: HashSet::new(),\n            literals_used: Vec::new(),\n            where_functions: HashMap::new(),\n            closure_count: 0,\n            parent_collector: self,\n        };\n\n        collector.visit_expr(&body.value);\n\n        (\n            collector.functions_called,\n            collector.methods_called,\n            collector.types_used.into_iter().collect(),\n            collector.literals_used,\n            collector.where_functions,\n        )\n    }\n\n    pub fn process_function_data(\n        &mut self,\n        sig: &rustc_hir::FnSig<'tcx>,\n        hir_id: HirId,\n        body_id: BodyId,\n        span: Span,\n    ) {\n        let def_id = hir_id.owner.to_def_id();\n\n        // Skip if not a local function\n        if !def_id.is_local() {\n            return;\n        }\n\n        let function_name = self.tcx.item_name(def_id).to_string();\n        let crate_name = self.tcx.crate_name(def_id.krate).to_string();\n        let module_path = self.current_module_path();\n\n        // Get fully qualified path\n        let fully_qualified_path = if module_path.is_empty() {\n            format!(\"{}::{}\", crate_name, function_name)\n        } else {\n            format!(\"{}::{}::{}\", crate_name, module_path, function_name)\n        };\n        // println!(\"{:?}\",fully_qualified_path);\n\n        // Source location info\n        let src_loc = self.format_span(span);\n        let src_code = self\n            .tcx\n            .sess\n            .source_map()\n            .span_to_snippet(span)\n            .unwrap_or_else(|_| \"<<source unavailable>>\".to_string());\n\n        let line_start = self.get_line_number(span);\n        let line_end = self.tcx.sess.source_map().lookup_char_pos(span.hi()).line;\n\n        // Check if this is a method (simplified)\n        let is_method = self.tcx.impl_of_method(def_id).is_some();\n        let self_type = None; // Simplified\n\n        let mut input_types = Vec::new();\n        for param in sig.decl.inputs.iter() {\n            if let Some(type_info) = self.extract_type_origin_info(param) {\n                input_types.push(type_info);\n            }\n        }\n\n        // Extract function outputs\n        let mut output_types = Vec::new();\n        if let rustc_hir::FnRetTy::Return(ty) = &sig.decl.output {\n            if let Some(type_info) = self.extract_type_origin_info(*ty) {\n                output_types.push(type_info);\n            }\n        } else {\n            // Add unit type for default return\n            output_types.push(TypeOriginInfo {\n                type_name: \"()\".to_string(),\n                crate_name: \"core\".to_string(),\n                module_path: \"primitive\".to_string(),\n                generic_args: Vec::new(),\n                is_generic_param: false,\n                src_location: \"\".to_string(),\n            });\n        }\n\n        // Extract additional metadata\n        let visibility = self.extract_visibility(hir_id.owner);\n        let doc_comments = self.extract_doc_comments(hir_id);\n        let attributes = self.get_attrs_string(hir_id);\n\n        // self.tcx.get_attrs(hir_id.owner.to_def_id(),rustc_span::sym::TyCtxt)\n        // let body = self.tcx.thir_body(body_id);\n        let body = self.tcx.hir().body(body_id);\n\n        // Collect function calls, method calls, literals, and types used\n        let (functions_called, methods_called, types_used, literals_used, where_functions) =\n            self.analyze_body(body);\n\n        // Create function data\n        let function_info = Function {\n            name: function_name,\n            fully_qualified_path,\n            is_method,\n            self_type,\n            input_types,\n            output_types,\n            types_used: types_used,\n            literals_used: literals_used,\n            functions_called: functions_called,\n            methods_called: methods_called,\n            where_functions: where_functions,\n            src_location: src_loc,\n            src_code,\n            line_number_start: line_start,\n            line_number_end: line_end,\n            crate_name,\n            module_path,\n            visibility,\n            doc_comments,\n            attributes,\n        };\n        // println!(\"{:?}\",function_info);\n        self.function_data.push(function_info);\n    }\n}",
      "references": []
    },
    {
      "name": "impl intravisit::Visitor<'tcx> for CallgraphVisitor<'tcx>",
      "kind": "Object",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 1376,
          "character": 0
        },
        "end": {
          "line": 1501,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 1376,
          "character": 41
        },
        "end": {
          "line": 1376,
          "character": 63
        }
      },
      "children": [
        {
          "name": "NestedFilter",
          "detail": "nested_filter::OnlyBodies",
          "kind": 26,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 1377,
              "character": 4
            },
            "end": {
              "line": 1377,
              "character": 50
            }
          },
          "selectionRange": {
            "start": {
              "line": 1377,
              "character": 9
            },
            "end": {
              "line": 1377,
              "character": 21
            }
          }
        },
        {
          "name": "nested_visit_map",
          "detail": "fn(&mut self) -> Self::Map",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 1379,
              "character": 4
            },
            "end": {
              "line": 1381,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 1379,
              "character": 7
            },
            "end": {
              "line": 1379,
              "character": 23
            }
          }
        },
        {
          "name": "visit_item",
          "detail": "fn(&mut self, item: &'tcx rustc_hir::Item<'_>)",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 1383,
              "character": 4
            },
            "end": {
              "line": 1439,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 1383,
              "character": 7
            },
            "end": {
              "line": 1383,
              "character": 17
            }
          }
        },
        {
          "name": "visit_trait_item",
          "detail": "fn(&mut self, ti: &'tcx rustc_hir::TraitItem<'_>)",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 1441,
              "character": 4
            },
            "end": {
              "line": 1460,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 1441,
              "character": 7
            },
            "end": {
              "line": 1441,
              "character": 23
            }
          }
        },
        {
          "name": "visit_impl_item",
          "detail": "fn(&mut self, ii: &'tcx rustc_hir::ImplItem<'_>)",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 1462,
              "character": 4
            },
            "end": {
              "line": 1500,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 1462,
              "character": 7
            },
            "end": {
              "line": 1462,
              "character": 22
            }
          }
        }
      ],
      "code_string": "impl<'tcx> intravisit::Visitor<'tcx> for CallgraphVisitor<'tcx> {\n    type NestedFilter = nested_filter::OnlyBodies;\n\n    fn nested_visit_map(&mut self) -> Self::Map {\n        self.tcx.hir()\n    }\n\n    fn visit_item(&mut self, item: &'tcx rustc_hir::Item<'_>) {\n        // skip_generated_code!(item.span);\n        let hir_id = item.hir_id();\n        // println!(\"{:?}\",hir_id);\n\n        // Handle modules - track module path for better function organization\n        if let rustc_hir::ItemKind::Mod(module) = &item.kind {\n            let def_id = hir_id.owner.to_def_id();\n\n            // Push module to stack\n            self.push_module(self.format_span(module.spans.inner_span));\n\n            // Process module items\n            intravisit::walk_item(self, item);\n\n            // Pop module from stack\n            self.pop_module();\n\n            return;\n        }\n\n        if let rustc_hir::ItemKind::Fn(sig, generics, body_id) = item.kind {\n            let def_id = hir_id.owner.to_def_id();\n            self.process_function_data(&sig, hir_id, body_id, item.span);\n\n            push_walk_pop!(self, def_id, intravisit::walk_item(self, item));\n\n            return;\n        }\n        if let rustc_hir::ItemKind::Trait(is_auto, unsafety, generics, _bounds, trait_items_) =\n            item.kind\n        {\n            let def_id = hir_id.owner.to_def_id();\n\n            // Process all trait items\n            for trait_item_ref in trait_items_ {\n                let trait_item = self.tcx.hir().trait_item(trait_item_ref.id);\n                self.visit_trait_item(trait_item);\n            }\n\n            push_walk_pop!(self, def_id, intravisit::walk_item(self, item));\n\n            return;\n        }\n\n        if let rustc_hir::ItemKind::Impl(impl_) = item.kind {\n            let def_id = hir_id.owner.to_def_id();\n            for impl_item_ref in impl_.items {\n                let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                self.visit_impl_item(impl_item);\n            }\n            push_walk_pop!(self, def_id, intravisit::walk_item(self, item));\n            return;\n        }\n        // traverse\n        intravisit::walk_item(self, item)\n    }\n\n    fn visit_trait_item(&mut self, ti: &'tcx rustc_hir::TraitItem<'_>) {\n        skip_generated_code!(ti.span);\n\n        let hir_id = ti.hir_id();\n        let def_id = hir_id.owner.to_def_id();\n\n        match ti.kind {\n            rustc_hir::TraitItemKind::Fn(sig, rustc_hir::TraitFn::Provided(body_id)) => {\n                self.process_function_data(&sig, hir_id, body_id, ti.span);\n\n                push_walk_pop!(self, def_id, intravisit::walk_trait_item(self, ti));\n\n                return;\n            }\n            _ => {}\n        }\n\n        // traverse\n        intravisit::walk_trait_item(self, ti)\n    }\n\n    fn visit_impl_item(&mut self, ii: &'tcx rustc_hir::ImplItem<'_>) {\n        // skip_generated_code!(ii.span);\n\n        let hir_id = ii.hir_id();\n        let def_id = hir_id.owner.to_def_id();\n\n        if let rustc_hir::ImplItemKind::Fn(sig, body_id) = ii.kind {\n            // Process impl method data\n            self.process_function_data(&sig, hir_id, body_id, ii.span);\n\n            // store link to decl\n            let mut decl_id = None;\n            if let Some(impl_id) = self.tcx.impl_of_method(def_id) {\n                if let Some(rustc_hir::Node::Item(item)) = self.tcx.hir().get_if_local(impl_id) {\n                    if let rustc_hir::ItemKind::Impl(impl_) = &item.kind {\n                        // the next one filters methods that are just associated\n                        // and do not belong to a struct\n                        if let Some(trait_def_id) = self.tcx.trait_id_of_impl(impl_id) {\n                            let item = self\n                                .tcx\n                                .associated_items(trait_def_id)\n                                .filter_by_name_unhygienic(ii.ident.name)\n                                .next(); // There should ideally be only one item matching the name\n                            if let Some(item) = item {\n                                decl_id = Some(item.def_id);\n                            };\n                        }\n                    }\n                }\n            }\n\n            push_walk_pop!(self, def_id, intravisit::walk_impl_item(self, ii));\n\n            return;\n        }\n\n        // traverse\n        intravisit::walk_impl_item(self, ii)\n    }\n}",
      "references": []
    }
  ],
  [
    {
      "name": "show_error",
      "detail": "fn(msg: impl AsRef<str>) -> !",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 16,
          "character": 0
        },
        "end": {
          "line": 19,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 16,
          "character": 3
        },
        "end": {
          "line": 16,
          "character": 13
        }
      },
      "code_string": "fn show_error(msg: impl AsRef<str>) -> ! {\n    println!(\"{}\", msg.as_ref());\n    std::process::exit(1)\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 16,
              "character": 0
            },
            "end": {
              "line": 16,
              "character": 2
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 18,
              "character": 4
            },
            "end": {
              "line": 18,
              "character": 25
            }
          }
        }
      ]
    },
    {
      "name": "has_arg_flag",
      "detail": "fn(name: &str) -> bool",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 21,
          "character": 0
        },
        "end": {
          "line": 26,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 22,
          "character": 3
        },
        "end": {
          "line": 22,
          "character": 15
        }
      },
      "code_string": "// Determines whether a `--flag` is present.\nfn has_arg_flag(name: &str) -> bool {\n    // Stop searching at `--`.\n    let mut args = std::env::args().take_while(|val| val != \"--\");\n    args.any(|val| val == name)\n}",
      "references": []
    },
    {
      "name": "get_arg_flag_value",
      "detail": "fn(name: &str) -> Option<String>",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 28,
          "character": 0
        },
        "end": {
          "line": 51,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 29,
          "character": 3
        },
        "end": {
          "line": 29,
          "character": 21
        }
      },
      "code_string": "/// Gets the value of a `--flag`.\nfn get_arg_flag_value(name: &str) -> Option<String> {\n    // Stop searching at `--`.\n    let mut args = std::env::args().take_while(|val| val != \"--\");\n    loop {\n        let arg = match args.next() {\n            Some(arg) => arg,\n            None => return None,\n        };\n        if !arg.starts_with(name) {\n            continue;\n        }\n        // Strip leading `name`.\n        let suffix = &arg[name.len()..];\n        if suffix.is_empty() {\n            // This argument is exactly `name`; the next one is the value.\n            return args.next();\n        } else if suffix.starts_with('=') {\n            // This argument is `name=value`; get the value.\n            // Strip leading `=`.\n            return Some(suffix[1..].to_owned());\n        }\n    }\n}",
      "references": []
    },
    {
      "name": "any_arg_flag",
      "detail": "fn<F>(name: &str, mut check: F) -> bool",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 53,
          "character": 0
        },
        "end": {
          "line": 88,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 53,
          "character": 3
        },
        "end": {
          "line": 53,
          "character": 15
        }
      },
      "code_string": "fn any_arg_flag<F>(name: &str, mut check: F) -> bool\nwhere\n    F: FnMut(&str) -> bool,\n{\n    // Stop searching at `--`.\n    let mut args = std::env::args().take_while(|val| val != \"--\");\n    loop {\n        let arg = match args.next() {\n            Some(arg) => arg,\n            None => return false,\n        };\n        if !arg.starts_with(name) {\n            continue;\n        }\n\n        // Strip leading `name`.\n        let suffix = &arg[name.len()..];\n        let value = if suffix.is_empty() {\n            // This argument is exactly `name`; the next one is the value.\n            match args.next() {\n                Some(arg) => arg,\n                None => return false,\n            }\n        } else if suffix.starts_with('=') {\n            // This argument is `name=value`; get the value.\n            // Strip leading `=`.\n            suffix[1..].to_owned()\n        } else {\n            return false;\n        };\n\n        if check(&value) {\n            return true;\n        }\n    }\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 81,
              "character": 12
            },
            "end": {
              "line": 81,
              "character": 18
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 74,
              "character": 24
            },
            "end": {
              "line": 74,
              "character": 30
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 53,
              "character": 0
            },
            "end": {
              "line": 53,
              "character": 2
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 85,
              "character": 12
            },
            "end": {
              "line": 85,
              "character": 18
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 62,
              "character": 20
            },
            "end": {
              "line": 62,
              "character": 26
            }
          }
        }
      ]
    },
    {
      "name": "get_first_arg_with_rs_suffix",
      "detail": "fn() -> Option<String>",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 90,
          "character": 0
        },
        "end": {
          "line": 95,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 91,
          "character": 3
        },
        "end": {
          "line": 91,
          "character": 31
        }
      },
      "code_string": "/// Finds the first argument ends with `.rs`.\nfn get_first_arg_with_rs_suffix() -> Option<String> {\n    // Stop searching at `--`.\n    let mut args = std::env::args().take_while(|val| val != \"--\");\n    args.find(|arg| arg.ends_with(\".rs\"))\n}",
      "references": []
    },
    {
      "name": "version_info",
      "detail": "fn() -> VersionMeta",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 97,
          "character": 0
        },
        "end": {
          "line": 100,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 97,
          "character": 3
        },
        "end": {
          "line": 97,
          "character": 15
        }
      },
      "code_string": "fn version_info() -> VersionMeta {\n    VersionMeta::for_command(Command::new(find_fdep()))\n        .expect(\"failed to determine underlying rustc version of Fdep\")\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 97,
              "character": 0
            },
            "end": {
              "line": 97,
              "character": 2
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 98,
              "character": 4
            },
            "end": {
              "line": 99,
              "character": 71
            }
          }
        }
      ]
    },
    {
      "name": "find_fdep",
      "detail": "fn() -> PathBuf",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 102,
          "character": 0
        },
        "end": {
          "line": 107,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 103,
          "character": 3
        },
        "end": {
          "line": 103,
          "character": 12
        }
      },
      "code_string": "/// Returns the path to the `fdep` binary\nfn find_fdep() -> PathBuf {\n    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n    path.set_file_name(\"fdep\");\n    path\n}",
      "references": []
    },
    {
      "name": "test_sysroot_consistency",
      "detail": "fn()",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 109,
          "character": 0
        },
        "end": {
          "line": 146,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 112,
          "character": 3
        },
        "end": {
          "line": 112,
          "character": 27
        }
      },
      "children": [
        {
          "name": "get_sysroot",
          "detail": "fn(mut cmd: Command) -> PathBuf",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 113,
              "character": 4
            },
            "end": {
              "line": 131,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 113,
              "character": 7
            },
            "end": {
              "line": 113,
              "character": 18
            }
          }
        }
      ],
      "code_string": "/// Make sure that the `fdep` and `rustc` binary are from the same sysroot.\n/// This can be violated e.g. when fdep is locally built and installed with a different\n/// toolchain than what is used when `cargo fdep` is run.\nfn test_sysroot_consistency() {\n    fn get_sysroot(mut cmd: Command) -> PathBuf {\n        let out = cmd\n            .arg(\"--print\")\n            .arg(\"sysroot\")\n            .output()\n            .expect(\"Failed to run rustc to get sysroot info\");\n        let stdout = String::from_utf8(out.stdout).expect(\"stdout is not valid UTF-8\");\n        let stderr = String::from_utf8(out.stderr).expect(\"stderr is not valid UTF-8\");\n        let stdout = stdout.trim();\n        assert!(\n            out.status.success(),\n            \"Bad status code when getting sysroot info.\\nstdout:\\n{}\\nstderr:\\n{}\",\n            stdout,\n            stderr\n        );\n        PathBuf::from(stdout)\n            .canonicalize()\n            .unwrap_or_else(|_| panic!(\"Failed to canonicalize sysroot: {}\", stdout))\n    }\n\n    let rustc_sysroot = get_sysroot(Command::new(\"rustc\"));\n    let fdep_sysroot = get_sysroot(Command::new(find_fdep()));\n\n    if rustc_sysroot != fdep_sysroot {\n        show_error(format!(\n            \"fdep was built for a different sysroot than the rustc in your current toolchain.\\n\\\n             Make sure you use the same toolchain to run fdep that you used to build it!\\n\\\n             rustc sysroot: `{}`\\n\\\n             fdep sysroot: `{}`\",\n            rustc_sysroot.display(),\n            fdep_sysroot.display()\n        ));\n    }\n}",
      "references": []
    },
    {
      "name": "clean_package",
      "detail": "fn(package_name: &str)",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 148,
          "character": 0
        },
        "end": {
          "line": 167,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 148,
          "character": 3
        },
        "end": {
          "line": 148,
          "character": 16
        }
      },
      "code_string": "fn clean_package(package_name: &str) {\n    let mut cmd = Command::new(\"cargo\");\n    cmd.arg(\"clean\");\n\n    cmd.arg(\"-p\");\n    cmd.arg(package_name);\n\n    cmd.arg(\"--target\");\n    cmd.arg(version_info().host);\n\n    let exit_status = cmd\n        .spawn()\n        .expect(\"could not run cargo clean\")\n        .wait()\n        .expect(\"failed to wait for cargo?\");\n\n    if !exit_status.success() {\n        show_error(format!(\"cargo clean failed\"));\n    }\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 148,
              "character": 0
            },
            "end": {
              "line": 148,
              "character": 2
            }
          }
        }
      ]
    },
    {
      "name": "main",
      "detail": "fn()",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 169,
          "character": 0
        },
        "end": {
          "line": 202,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 169,
          "character": 3
        },
        "end": {
          "line": 169,
          "character": 7
        }
      },
      "code_string": "fn main() {\n    let mut args = std::env::args();\n    // Skip binary name.\n    args.next().unwrap();\n\n    let Some(first) = args.next() else {\n        show_error(\n            \"`cargo-fdep` called without first argument; please only invoke this binary through `cargo fdep`\"\n        )\n    };\n    match first.as_str() {\n        \"fdep\" => {\n            // eprintln!(\"Running cargo fdep\");\n            // This arm is for when `cargo fdep` is called. We call `cargo rustc` for each applicable target,\n            // but with the `RUSTC` env var set to the `cargo-fdep` binary so that we come back in the other branch,\n            // and dispatch the invocations to `rustc` and `fdep`, respectively.\n            in_cargo_fdep();\n            // eprintln!(\"cargo fdep finished\");\n        }\n        // Check if arg is a path that ends with \"/rustc\"\n        arg if arg.ends_with(\"rustc\") => {\n            // eprintln!(\"Running cargo rustc\");\n            // This arm is executed when `cargo-fdep` runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n            // dependencies get dispatched to `rustc`, the final test/binary to `fdep`.\n            inside_cargo_rustc();\n            // eprintln!(\"cargo rustc finished\");\n        }\n        _ => {\n            show_error(\n                \"`cargo-fdep` must be called with either `fdep` or `rustc` as first argument.\",\n            );\n        }\n    }\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 169,
              "character": 0
            },
            "end": {
              "line": 169,
              "character": 2
            }
          }
        }
      ]
    },
    {
      "name": "TargetKind",
      "kind": "Enum",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 204,
          "character": 0
        },
        "end": {
          "line": 209,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 205,
          "character": 5
        },
        "end": {
          "line": 205,
          "character": 15
        }
      },
      "children": [
        {
          "name": "Library",
          "kind": 22,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 206,
              "character": 4
            },
            "end": {
              "line": 206,
              "character": 15
            }
          },
          "selectionRange": {
            "start": {
              "line": 206,
              "character": 4
            },
            "end": {
              "line": 206,
              "character": 11
            }
          }
        },
        {
          "name": "Bin",
          "kind": 22,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 207,
              "character": 4
            },
            "end": {
              "line": 207,
              "character": 7
            }
          },
          "selectionRange": {
            "start": {
              "line": 207,
              "character": 4
            },
            "end": {
              "line": 207,
              "character": 7
            }
          }
        },
        {
          "name": "Unknown",
          "kind": 22,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 208,
              "character": 4
            },
            "end": {
              "line": 208,
              "character": 11
            }
          },
          "selectionRange": {
            "start": {
              "line": 208,
              "character": 4
            },
            "end": {
              "line": 208,
              "character": 11
            }
          }
        }
      ],
      "code_string": "#[repr(u8)]\nenum TargetKind {\n    Library = 0,\n    Bin,\n    Unknown,\n}",
      "references": []
    },
    {
      "name": "impl TargetKind",
      "kind": "Object",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 211,
          "character": 0
        },
        "end": {
          "line": 215,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 211,
          "character": 5
        },
        "end": {
          "line": 211,
          "character": 15
        }
      },
      "children": [
        {
          "name": "is_lib_str",
          "detail": "fn(s: &str) -> bool",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 212,
              "character": 4
            },
            "end": {
              "line": 214,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 212,
              "character": 7
            },
            "end": {
              "line": 212,
              "character": 17
            }
          }
        }
      ],
      "code_string": "impl TargetKind {\n    fn is_lib_str(s: &str) -> bool {\n        s == \"lib\" || s == \"rlib\" || s == \"staticlib\"\n    }\n}",
      "references": []
    },
    {
      "name": "impl From<&cargo_metadata::Target> for TargetKind",
      "kind": "Object",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 217,
          "character": 0
        },
        "end": {
          "line": 227,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 217,
          "character": 39
        },
        "end": {
          "line": 217,
          "character": 49
        }
      },
      "children": [
        {
          "name": "from",
          "detail": "fn(target: &cargo_metadata::Target) -> Self",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 218,
              "character": 4
            },
            "end": {
              "line": 226,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 218,
              "character": 7
            },
            "end": {
              "line": 218,
              "character": 11
            }
          }
        }
      ],
      "code_string": "impl From<&cargo_metadata::Target> for TargetKind {\n    fn from(target: &cargo_metadata::Target) -> Self {\n        if target.kind.iter().any(|s| TargetKind::is_lib_str(s)) {\n            TargetKind::Library\n        } else if let Some(\"bin\") = target.kind.get(0).map(|s| s.as_ref()) {\n            TargetKind::Bin\n        } else {\n            TargetKind::Unknown\n        }\n    }\n}",
      "references": []
    },
    {
      "name": "impl Display for TargetKind",
      "kind": "Object",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 229,
          "character": 0
        },
        "end": {
          "line": 241,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 229,
          "character": 17
        },
        "end": {
          "line": 229,
          "character": 27
        }
      },
      "children": [
        {
          "name": "fmt",
          "detail": "fn(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 230,
              "character": 4
            },
            "end": {
              "line": 240,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 230,
              "character": 7
            },
            "end": {
              "line": 230,
              "character": 10
            }
          }
        }
      ],
      "code_string": "impl Display for TargetKind {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                TargetKind::Library => \"lib\",\n                TargetKind::Bin => \"bin\",\n                TargetKind::Unknown => \"unknown\",\n            }\n        )\n    }\n}",
      "references": []
    },
    {
      "name": "in_cargo_fdep",
      "detail": "fn()",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 243,
          "character": 0
        },
        "end": {
          "line": 307,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 243,
          "character": 3
        },
        "end": {
          "line": 243,
          "character": 16
        }
      },
      "code_string": "fn in_cargo_fdep() {\n    let verbose: bool = has_arg_flag(\"-v\");\n\n    // Some basic sanity checks\n    test_sysroot_consistency();\n\n    let manifest_path =\n        get_arg_flag_value(\"--manifest-path\").map(|m| Path::new(&m).canonicalize().unwrap());\n\n    let mut cmd = cargo_metadata::MetadataCommand::new();\n    if let Some(manifest_path) = &manifest_path {\n        cmd.manifest_path(manifest_path);\n    }\n    let mut metadata = match cmd.exec() {\n        Ok(metadata) => metadata,\n        Err(e) => show_error(format!(\"Could not obtain Cargo metadata\\n{}\", e)),\n    };\n    let current_dir = std::env::current_dir();\n\n    if metadata.packages.len() != 0 {\n        let package_index = metadata.packages.iter().position(|package| {\n            let package_manifest_path = Path::new(&package.manifest_path);\n\n            if let Some(manifest_path) = &manifest_path {\n                package_manifest_path == manifest_path\n            } else {\n                let current_dir = current_dir\n                    .as_ref()\n                    .expect(\"could not read current directory\");\n                let package_manifest_directory = package_manifest_path\n                    .parent()\n                    .expect(\"could not find parent directory of package manifest\");\n                package_manifest_directory == current_dir\n            }\n        });\n        // let mut visited_packages = Vec::new();\n        match package_index {\n            Some(index) => process_package(metadata.packages.remove(index)),\n            None => {\n                println!(\"{:#?}\", metadata.workspace_members);\n                // println!(\"{:?}\", metadata.workspace_default_packages());\n                println!(\"{:#?}\", metadata.root_package());\n                let independant_packages = get_independant_packages(&metadata);\n                for package in independant_packages {\n                    process_package(package.clone());\n                }\n\n                // root_package\n                // if metadata.workspace_members.len() != 0 {\n                //     for member in metadata.workspace_members.iter() {\n                //         let package = metadata[member].clone();\n                //         let package_manifest_path = Path::new(&package.manifest_path);\n                //         if package_manifest_path.starts_with(current_dir.as_ref().unwrap())\n                //             && !visited_packages.contains(&package.id.clone())\n                //         {\n                //             println!(\"{:?}\", package.name);\n                //             process_package(package.clone());\n                //             visited_packages.push(package.id);\n                //         }\n                //     }\n                // }\n            }\n        }\n    }\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 280,
              "character": 27
            },
            "end": {
              "line": 280,
              "character": 75
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 243,
              "character": 0
            },
            "end": {
              "line": 243,
              "character": 2
            }
          }
        }
      ]
    },
    {
      "name": "get_independant_packages",
      "detail": "fn(metadata: &Metadata) -> Vec<&Package>",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 309,
          "character": 0
        },
        "end": {
          "line": 335,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 309,
          "character": 3
        },
        "end": {
          "line": 309,
          "character": 27
        }
      },
      "code_string": "fn get_independant_packages(metadata: &Metadata) -> Vec<&Package> {\n    let all_packages = metadata.workspace_default_packages();\n\n    // 1. Gather all crate names\n    let all_names: HashSet<_> = all_packages.iter().map(|pkg| pkg.name.clone()).collect();\n\n    // 2. Gather names of local workspace dependencies\n    let mut dep_names = HashSet::new();\n    for pkg in &all_packages {\n        for dep in &pkg.dependencies {\n            if dep.source.is_none() {\n                dep_names.insert(dep.name.clone());\n            }\n        }\n    }\n\n    // 3. Root package names = not depended on by any other package\n    let root_names: HashSet<_> = all_names.difference(&dep_names).cloned().collect();\n\n    // 4. Collect the actual Package structs matching the root names\n    let root_packages: Vec<_> = all_packages\n        .into_iter()\n        .filter(|pkg| root_names.contains(&pkg.name))\n        .collect();\n\n    root_packages\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 309,
              "character": 0
            },
            "end": {
              "line": 309,
              "character": 2
            }
          }
        },
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 334,
              "character": 4
            },
            "end": {
              "line": 334,
              "character": 17
            }
          }
        }
      ]
    },
    {
      "name": "process_package",
      "detail": "fn(package: cargo_metadata::Package)",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 337,
          "character": 0
        },
        "end": {
          "line": 441,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 337,
          "character": 3
        },
        "end": {
          "line": 337,
          "character": 18
        }
      },
      "code_string": "fn process_package(package: cargo_metadata::Package) {\n    let mut targets: Vec<_> = package.targets.into_iter().collect();\n    let verbose = std::env::var_os(\"FDEP_VERBOSE\").is_some();\n    // Ensure `lib` is compiled before `bin`\n    targets.sort_by_key(|target| TargetKind::from(target) as u8);\n\n    for target in targets {\n        // Skip `cargo fdep`\n        let mut args = std::env::args().skip(2);\n        let kind = TargetKind::from(&target);\n\n        println!(\"Target name: {}\", &target.name);\n\n        // Now we run `cargo check $FLAGS $ARGS`, giving the user the\n        // change to add additional arguments. `FLAGS` is set to identify\n        // this target. The user gets to control what gets actually passed to fdep.\n        let mut cmd = Command::new(\"cargo\");\n        cmd.arg(\"check\");\n\n        match kind {\n            TargetKind::Bin => {\n                // Analyze all the binaries.\n                cmd.arg(\"--bin\").arg(&target.name);\n            }\n            TargetKind::Library => {\n                // There can be only one lib in a crate.\n                cmd.arg(\"--lib\");\n                // Clean the result to disable Cargo's freshness check\n                clean_package(&package.name);\n            }\n            TargetKind::Unknown => {\n                println!(\n                    \"Target {}:{} is not supported\",\n                    target.kind.as_slice().join(\"/\"),\n                    &target.name\n                );\n                continue;\n            }\n        }\n\n        if !cfg!(debug_assertions) && !verbose {\n            cmd.arg(\"-q\");\n        }\n\n        // Forward user-defined `cargo` args until first `--`.\n        while let Some(arg) = args.next() {\n            if arg == \"--\" {\n                break;\n            }\n            cmd.arg(arg);\n        }\n\n        // We want to always run `cargo` with `--target`. This later helps us detect\n        // which crates are proc-macro/build-script (host crates) and which crates are\n        // needed for the program itself.\n        if get_arg_flag_value(\"--target\").is_none() {\n            // When no `--target` is given, default to the host.\n            cmd.arg(\"--target\");\n            cmd.arg(version_info().host);\n        }\n\n        // Serialize the remaining args into a special environment variable.\n        // This will be read by `inside_cargo_rustc` when we go to invoke\n        // our actual target crate (the binary or the test we are running).\n        // Since we're using \"cargo check\", we have no other way of passing\n        // these arguments.\n        let args_vec: Vec<String> = args.collect();\n        cmd.env(\n            \"FDEP_ARGS\",\n            serde_json::to_string(&args_vec).expect(\"failed to serialize args\"),\n        );\n\n        // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n        // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n        // the two codepaths.\n        if env::var_os(\"RUSTC_WRAPPER\").is_some() {\n            eprintln!(\"WARNING: Ignoring existing `RUSTC_WRAPPER` environment variable, fdep does not support wrapping.\");\n        }\n\n        let path = std::env::current_exe().expect(\"current executable path invalid\");\n        cmd.env(\"RUSTC_WRAPPER\", path);\n        if verbose {\n            cmd.env(\"FDEP_VERBOSE\", \"\"); // this makes `inside_cargo_rustc` verbose.\n            eprintln!(\"+ {:?}\", cmd);\n        }\n\n        let mut child = cmd.spawn().expect(\"could not run cargo check\");\n        // 1 hour timeout\n        match child\n            .wait_timeout(Duration::from_secs(60 * 60))\n            .expect(\"failed to wait for subprocess\")\n        {\n            Some(exit_status) => {\n                if !exit_status.success() {\n                    show_error(\"Finished with non-zero exit code\");\n                }\n            }\n            None => {\n                child.kill().expect(\"failed to kill subprocess\");\n                child.wait().expect(\"failed to wait for subprocess\");\n                show_error(\"Killed due to timeout\");\n            }\n        };\n    }\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 337,
              "character": 0
            },
            "end": {
              "line": 337,
              "character": 2
            }
          }
        }
      ]
    },
    {
      "name": "inside_cargo_rustc",
      "detail": "fn()",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 443,
          "character": 0
        },
        "end": {
          "line": 537,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 443,
          "character": 3
        },
        "end": {
          "line": 443,
          "character": 21
        }
      },
      "children": [
        {
          "name": "contains_target_flag",
          "detail": "fn() -> bool",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 444,
              "character": 4
            },
            "end": {
              "line": 456,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 454,
              "character": 7
            },
            "end": {
              "line": 454,
              "character": 27
            }
          }
        },
        {
          "name": "is_target_crate",
          "detail": "fn() -> bool",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 458,
              "character": 4
            },
            "end": {
              "line": 470,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 462,
              "character": 7
            },
            "end": {
              "line": 462,
              "character": 22
            }
          }
        },
        {
          "name": "is_crate_type_lib",
          "detail": "fn() -> bool",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 472,
              "character": 4
            },
            "end": {
              "line": 474,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 472,
              "character": 7
            },
            "end": {
              "line": 472,
              "character": 24
            }
          }
        },
        {
          "name": "run_command",
          "detail": "fn(mut cmd: Command)",
          "kind": 12,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 476,
              "character": 4
            },
            "end": {
              "line": 491,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 476,
              "character": 7
            },
            "end": {
              "line": 476,
              "character": 18
            }
          }
        }
      ],
      "code_string": "fn inside_cargo_rustc() {\n    /// Determines if we are being invoked (as rustc) to build a crate for\n    /// the \"target\" architecture, in contrast to the \"host\" architecture.\n    /// Host crates are for build scripts and proc macros and still need to\n    /// be built like normal; target crates need to be built for or interpreted\n    /// by fdep.\n    ///\n    /// Currently, we detect this by checking for \"--target=\", which is\n    /// never set for host crates. This matches what rustc bootstrap does,\n    /// which hopefully makes it \"reliable enough\". This relies on us always\n    /// invoking cargo itself with `--target`, which `in_cargo_fdep` ensures.\n    fn contains_target_flag() -> bool {\n        get_arg_flag_value(\"--target\").is_some()\n    }\n\n    /// Returns whether we are building the target crate.\n    /// Cargo passes the file name as a relative address when building the local crate,\n    /// such as `crawl/src/bin/unsafe-counter.rs` when building the target crate.\n    /// This might not be a stable behavior, but let's rely on this for now.\n    fn is_target_crate() -> bool {\n        let entry_path_arg = match get_first_arg_with_rs_suffix() {\n            Some(arg) => arg,\n            None => return false,\n        };\n        let entry_path: &Path = entry_path_arg.as_ref();\n\n        entry_path.is_relative()\n    }\n\n    fn is_crate_type_lib() -> bool {\n        any_arg_flag(\"--crate-type\", TargetKind::is_lib_str)\n    }\n\n    fn run_command(mut cmd: Command) {\n        // Run it.\n        let verbose = std::env::var_os(\"FDEP_VERBOSE\").is_some();\n        if verbose {\n            eprintln!(\"+ {:?}\", cmd);\n        }\n\n        match cmd.status() {\n            Ok(exit) => {\n                if !exit.success() {\n                    std::process::exit(exit.code().unwrap_or(42));\n                }\n            }\n            Err(e) => panic!(\"error running {:?}:\\n{:?}\", cmd, e),\n        }\n    }\n\n    // TODO: Miri sets custom sysroot here, check if it is needed for us (FDEP-30)\n\n    let is_direct_target = contains_target_flag() && is_target_crate();\n    let mut is_additional_target = false;\n\n    if is_direct_target || is_additional_target {\n        let mut cmd = Command::new(find_fdep());\n        cmd.args(std::env::args().skip(2)); // skip `cargo-fdep rustc`\n\n        // This is the local crate that we want to analyze with Fdep.\n        // (Testing `target_crate` is needed to exclude build scripts.)\n        // We deserialize the arguments that are meant for Fdep from the special\n        // environment variable \"FDEP_ARGS\", and feed them to the 'fdep' binary.\n        //\n        // `env::var` is okay here, well-formed JSON is always UTF-8.\n        let magic = std::env::var(\"FDEP_ARGS\").expect(\"missing FDEP_ARGS\");\n        let fdep_args: Vec<String> =\n            serde_json::from_str(&magic).expect(\"failed to deserialize FDEP_ARGS\");\n        cmd.args(fdep_args);\n\n        run_command(cmd);\n    }\n\n    // Fdep does not build anything.\n    // We need to run rustc (or sccache) to build dependencies.\n    if !is_direct_target || is_crate_type_lib() {\n        let cmd = match which::which(\"sccache\") {\n            Ok(sccache_path) => {\n                let mut cmd = Command::new(&sccache_path);\n                // [\"cargo-fdep\", \"rustc\", ...]\n                cmd.args(std::env::args().skip(1));\n                cmd\n            }\n            Err(_) => {\n                // sccache was not found, use vanilla rustc\n                let mut cmd = Command::new(\"rustc\");\n                // [\"cargo-fdep\", \"rustc\", ...]\n                cmd.args(std::env::args().skip(2));\n                cmd\n            }\n        };\n\n        run_command(cmd);\n    }\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/cargo-fdep.rs",
          "range": {
            "start": {
              "line": 443,
              "character": 0
            },
            "end": {
              "line": 443,
              "character": 2
            }
          }
        }
      ]
    }
  ],
  [
    {
      "name": "CallgraphCallbacks",
      "kind": "Struct",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 12,
          "character": 0
        },
        "end": {
          "line": 14,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 12,
          "character": 7
        },
        "end": {
          "line": 12,
          "character": 25
        }
      },
      "children": [
        {
          "name": "output_dir",
          "detail": "Option<PathBuf>",
          "kind": 8,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 13,
              "character": 4
            },
            "end": {
              "line": 13,
              "character": 31
            }
          },
          "selectionRange": {
            "start": {
              "line": 13,
              "character": 4
            },
            "end": {
              "line": 13,
              "character": 14
            }
          }
        }
      ],
      "code_string": "struct CallgraphCallbacks {\n    output_dir: Option<PathBuf>,\n}",
      "references": []
    },
    {
      "name": "impl Callbacks for CallgraphCallbacks",
      "kind": "Object",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 16,
          "character": 0
        },
        "end": {
          "line": 28,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 16,
          "character": 19
        },
        "end": {
          "line": 16,
          "character": 37
        }
      },
      "children": [
        {
          "name": "after_analysis",
          "detail": "fn<'tcx>( &mut self, _compiler: &Compiler, queries: &'tcx Queries<'tcx>, ) -> Compilation",
          "kind": 6,
          "tags": [],
          "deprecated": false,
          "range": {
            "start": {
              "line": 17,
              "character": 4
            },
            "end": {
              "line": 27,
              "character": 5
            }
          },
          "selectionRange": {
            "start": {
              "line": 17,
              "character": 7
            },
            "end": {
              "line": 17,
              "character": 21
            }
          }
        }
      ],
      "code_string": "impl Callbacks for CallgraphCallbacks {\n    fn after_analysis<'tcx>(\n        &mut self,\n        _compiler: &Compiler,\n        queries: &'tcx Queries<'tcx>,\n    ) -> Compilation {\n        queries.global_ctxt().unwrap().enter(|tcx| {\n            analyze(&tcx);\n        });\n\n        Compilation::Stop\n    }\n}",
      "references": []
    },
    {
      "name": "main",
      "detail": "fn()",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 30,
          "character": 0
        },
        "end": {
          "line": 55,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 30,
          "character": 3
        },
        "end": {
          "line": 30,
          "character": 7
        }
      },
      "code_string": "fn main() {\n    let mut args: Vec<_> = std::env::args().collect();\n\n    // Make sure we use the right default sysroot. The default sysroot is wrong,\n    // because `get_or_default_sysroot` in `librustc_session` bases that on `current_exe`.\n    //\n    // Make sure we always call `compile_time_sysroot` as that also does some sanity-checks\n    // of the environment we were built in.\n    // FIXME: Ideally we'd turn a bad build env into a compile-time error via CTFE or so.\n    if let Some(sysroot) = compile_time_sysroot() {\n        let sysroot_flag = \"--sysroot\";\n        if !args.iter().any(|e| e == sysroot_flag) {\n            // We need to overwrite the default that librustc_session would compute.\n            args.push(sysroot_flag.to_owned());\n            args.push(sysroot);\n        }\n    }\n\n    // Determine output directory from command-line arguments\n    let output_dir = get_output_dir(&args);\n\n    let mut calls = CallgraphCallbacks { output_dir };\n\n    let run_compiler = rustc_driver::RunCompiler::new(&args, &mut calls);\n    let _ = run_compiler.run();\n}",
      "references": [
        {
          "uri": "file:///Users/eswar.tadiparth/Documents/open-source/fdep-rs/src/bin/fdep.rs",
          "range": {
            "start": {
              "line": 30,
              "character": 0
            },
            "end": {
              "line": 30,
              "character": 2
            }
          }
        }
      ]
    },
    {
      "name": "get_output_dir",
      "detail": "fn(args: &[String]) -> Option<PathBuf>",
      "kind": "Function",
      "tags": [],
      "deprecated": false,
      "range": {
        "start": {
          "line": 57,
          "character": 0
        },
        "end": {
          "line": 72,
          "character": 1
        }
      },
      "selectionRange": {
        "start": {
          "line": 58,
          "character": 3
        },
        "end": {
          "line": 58,
          "character": 17
        }
      },
      "code_string": "// Helper function to determine output directory from command-line arguments\nfn get_output_dir(args: &[String]) -> Option<PathBuf> {\n    for (i, arg) in args.iter().enumerate() {\n        if arg == \"--output\" || arg == \"-o\" {\n            if i + 1 < args.len() {\n                return Some(PathBuf::from(&args[i + 1]));\n            }\n        }\n\n        if arg.starts_with(\"--output=\") {\n            let path = arg.split('=').nth(1)?;\n            return Some(PathBuf::from(path));\n        }\n    }\n    None\n}",
      "references": []
    }
  ]
]